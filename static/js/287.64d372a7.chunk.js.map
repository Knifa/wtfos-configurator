{"version":3,"file":"static/js/287.64d372a7.chunk.js","mappings":"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","sources":["features/osd-overlay/video-worker/shared.ts","features/osd-overlay/video-worker/processor.ts","features/osd-overlay/video-worker/fonts.ts","features/osd-overlay/video-worker/osd.ts","features/osd-overlay/video-worker/worker.ts","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/compat get default export","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["namespace VideoWorkerShared {\n  export const enum MessageType {\n    FILE_IN,\n    FILE_OUT,\n    PROGRESS_INIT,\n    PROGRESS_UPDATE,\n  }\n\n  export interface FileInMessage {\n    type: MessageType.FILE_IN;\n    fontFiles: File[];\n    osdFile: File;\n    videoFile: File;\n  }\n\n  export interface FileOutMessage {\n    type: MessageType.FILE_OUT;\n    buffer: ArrayBuffer;\n  }\n\n  export interface ProgressInitMessage {\n    type: MessageType.PROGRESS_INIT;\n    expectedFrames: number;\n  }\n\n  export interface ProgressUpdateMessage {\n    type: MessageType.PROGRESS_UPDATE;\n    currentFrame?: number;\n    preview?: ImageBitmap;\n  }\n\n  export type Message =\n    | FileInMessage\n    | FileOutMessage\n    | ProgressInitMessage\n    | ProgressUpdateMessage;\n}\n\nexport default VideoWorkerShared;\n","import MP4Box from \"mp4box\";\nimport VideoWorkerShared from \"./shared\";\nimport { StreamDataView } from \"stream-data-view\";\n\nconst MAX_QUEUE_SIZE = 30;\nconst KEYFRAME_INTERVAL = 60;\nconst TINY_FRAME_SIZE = 100;\n\nfunction avcCBoxToDescription(avcCBox: any): ArrayBuffer {\n  const stream = new StreamDataView(undefined, true);\n\n  stream.setNextUint8(avcCBox.configurationVersion);\n  stream.setNextUint8(avcCBox.AVCProfileIndication);\n  stream.setNextUint8(avcCBox.profile_compatibility);\n  stream.setNextUint8(avcCBox.AVCLevelIndication);\n  stream.setNextUint8(avcCBox.lengthSizeMinusOne + (63 << 2));\n\n  stream.setNextUint8(avcCBox.nb_SPS_nalus + (7 << 5));\n  for (let i = 0; i < avcCBox.SPS.length; i++) {\n    stream.setNextUint16(avcCBox.SPS[i].length);\n    for (let j = 0; j < avcCBox.SPS[i].length; j++) {\n      stream.setNextUint8(avcCBox.SPS[i].nalu[j]);\n    }\n  }\n\n  stream.setNextUint8(avcCBox.nb_PPS_nalus);\n  for (let i = 0; i < avcCBox.PPS.length; i++) {\n    stream.setNextUint16(avcCBox.PPS[i].length);\n    for (let j = 0; j < avcCBox.PPS[i].length; j++) {\n      stream.setNextUint8(avcCBox.PPS[i].nalu[j]);\n    }\n  }\n\n  if (avcCBox.ext) {\n    for (let i = 0; i < avcCBox.ext.length; i++) {\n      stream.setNextUint8(avcCBox.ext[i]);\n    }\n  }\n\n  return stream.getBuffer();\n}\n\ntype InfoReadyCallback = (info: MP4Box.ISOFileInfo) => void;\ntype ModifyFrameCallback = (frame: VideoFrame, index: number) => VideoFrame;\ntype ProgressInitCallback = (total: number) => void;\ntype ProgressCallback = (processed?: number, preview?: ImageBitmap) => void;\n\nexport interface ProcessorOptions {\n  infoReady: InfoReadyCallback;\n  modifyFrame: ModifyFrameCallback;\n  progressInit: ProgressInitCallback;\n  progressUpdate: ProgressCallback;\n}\n\nexport class Processor {\n  decoder?: VideoDecoder;\n  encoder?: VideoEncoder;\n\n  inFile?: MP4Box.ISOFile;\n  inInfo?: MP4Box.ISOFileInfo;\n  outFile?: MP4Box.ISOFile;\n\n  expectedFrames: number = 0;\n  framesDecoded: number = 0;\n  framesEncoded: number = 0;\n  queuedForDecode: number = 0;\n  queuedForEncode: number = 0;\n  outTrackId?: number;\n\n  infoReady: InfoReadyCallback;\n  modifyFrame: ModifyFrameCallback;\n  progressInit: ProgressInitCallback;\n  progressUpdate: ProgressCallback;\n\n  samples: MP4Box.VideoSample[] = [];\n\n  constructor(options: ProcessorOptions) {\n    this.infoReady = options.infoReady;\n    this.modifyFrame = options.modifyFrame;\n    this.progressInit = options.progressInit;\n    this.progressUpdate = options.progressUpdate;\n  }\n\n  reset() {\n    this.inFile = MP4Box.createFile();\n    this.inFile.onReady = this.onInInfoReady.bind(this);\n    this.inFile.onSamples = this.onInSamples.bind(this);\n    this.inFile.onError = this.onInError.bind(this);\n\n    this.outFile = MP4Box.createFile();\n    this.outTrackId = undefined;\n\n    if (this.encoder) {\n      this.encoder.close();\n    }\n\n    this.encoder = new VideoEncoder({\n      output: this.handleEncodedFrame.bind(this),\n      error: this.handleEncoderError.bind(this),\n    });\n\n    if (this.decoder) {\n      this.decoder.close();\n    }\n\n    this.decoder = new VideoDecoder({\n      output: this.handleDecodedFrame.bind(this),\n      error: this.handleDecoderError.bind(this),\n    });\n\n    this.samples = [];\n  }\n\n  async processFile(file: File) {\n    this.reset();\n\n    const stream = file.stream();\n    const reader = stream.getReader();\n\n    let bytesRead = 0;\n    while (true) { // eslint-disable-line no-constant-condition\n      const {\n        done,\n        value,\n      } = await reader.read();\n\n      if (done) {\n        break;\n      }\n\n      const buffer = value.buffer;\n      (buffer as any).fileStart = bytesRead;\n      this.inFile!.appendBuffer(buffer);\n      bytesRead += value.byteLength;\n    }\n  }\n\n  processSamples(options: { width: number; height: number }) {\n    if (!this.inInfo) {\n      throw new Error(\"No info?\");\n    }\n\n    this.encoder!.configure({\n      codec: \"avc1.42003d\",\n      width: options.width,\n      height: options.height,\n      bitrate: this.inInfo.videoTracks[0].bitrate,\n      framerate: 60,\n      latencyMode: \"quality\",\n    });\n\n    this.expectedFrames = this.inInfo.videoTracks[0].nb_samples;\n    this.framesDecoded = 0;\n    this.framesEncoded = 0;\n\n    this.progressInit(this.expectedFrames);\n\n    this.inFile!.setExtractionOptions(this.inInfo.videoTracks[0].id, undefined, {\n      nbSamples: 1,\n      rapAlignement: false,\n    });\n    this.inFile!.start();\n    this.inFile!.flush();\n  }\n\n  onInInfoReady(info: MP4Box.ISOFileInfo) {\n    this.inInfo = info;\n\n    this.decoder!.configure({\n      codec: info.videoTracks[0].codec,\n      codedWidth: info.videoTracks[0].track_width,\n      codedHeight: info.videoTracks[0].track_height,\n      description: avcCBoxToDescription(\n        (this.inFile as any).moov.traks[0].mdia.minf.stbl.stsd.entries[0].avcC\n      ),\n      optimizeForLatency: false,\n    });\n\n    this.infoReady(info);\n  }\n\n  onInSamples(trackId: unknown, user: unknown, samples: MP4Box.VideoSample[]) {\n    for (const sample of samples) {\n      if (sample.size <= TINY_FRAME_SIZE) {\n        console.warn(`Tiny frame (number: ${sample.number}, ${sample.size} bytes) detected, skipping.`);\n        this.expectedFrames--;\n      } else {\n        this.samples.push(sample);\n      }\n    }\n\n    if (this.samples.length === this.expectedFrames) {\n      // setInterval(() => {\n      //   console.debug(`Decoder queue size: ${this.decoder!.decodeQueueSize}`);\n      //   console.debug(`Encoder queue size: ${this.encoder!.encodeQueueSize}`);\n      //   console.debug(`Queued for decode: ${this.queuedForDecode}`);\n      //   console.debug(`Queued for encode: ${this.queuedForEncode}`);\n      //   console.debug(`Samples queue size: ${this.samples.length}`);\n      //   console.debug(`Current decoding frame: ${this.framesDecoded}`);\n      //   console.debug(`Current encoding frame: ${this.framesEncoded}`);\n      //   console.debug(`Expected frames: ${this.expectedFrames}`);\n      // }, 1000);\n\n      this.decodeNextSamples();\n    }\n  }\n\n  decodeNextSamples() {\n    if ((this.decoder!.decodeQueueSize >= MAX_QUEUE_SIZE || this.encoder!.encodeQueueSize >= MAX_QUEUE_SIZE) && !(this.samples.length < MAX_QUEUE_SIZE)) {\n      // console.debug(\"Asked to queue but encoder/decoder is busy, aborting\");\n      return;\n    }\n\n    const sample = this.samples.shift();\n    if (!sample) {\n      throw Error(\"Tried to pull sample from queue but queue is empty!\");\n    }\n\n    const chunk = new EncodedVideoChunk({\n      data: sample.data,\n      duration: Math.floor((sample.duration / sample.timescale) * 1_000_000),\n      timestamp: Math.floor((sample.dts / sample.timescale) * 1_000_000),\n      type: sample.is_sync ? \"key\" : \"delta\",\n    });\n\n    this.decoder!.decode(chunk);\n    this.queuedForDecode++;\n\n    if (this.samples.length > 0 && !this.samples[0].is_sync) {\n      this.decodeNextSamples();\n    } else {\n      console.debug(`Flushing decoder at decoded frame ${this.framesDecoded}`);\n      this.decoder!.flush();\n    }\n  }\n\n\n  handleDecodedFrame(frame: VideoFrame) {\n    // console.debug(`Decoded frame ${this.framesDecoded}`);\n\n    if (this.framesDecoded % KEYFRAME_INTERVAL === 0) {\n      console.debug(`Flushing encoder at decoded frame ${this.framesDecoded}, keyframe incoming.`);\n      this.encoder!.flush();\n    }\n\n    const modifiedFrame = this.modifyFrame!(frame, this.framesDecoded);\n    frame.close();\n\n    this.encoder!.encode(modifiedFrame, { keyFrame: this.framesDecoded % KEYFRAME_INTERVAL === 0 });\n\n    this.queuedForEncode++;\n\n    if (this.framesDecoded % KEYFRAME_INTERVAL === 0) {\n      createImageBitmap(modifiedFrame).then((previewBitmap) => {\n        this.progressUpdate(undefined, previewBitmap);\n      });\n    }\n    modifiedFrame.close();\n\n    this.framesDecoded++;\n    this.inFile!.releaseUsedSamples(this.inInfo!.videoTracks[0].id, this.framesDecoded);\n\n    if (this.framesDecoded === this.expectedFrames) {\n      console.debug(`Flushing encoder at decoded frame ${this.framesDecoded}, last frame.`);\n      this.encoder!.flush();\n    }\n  }\n\n  handleEncodedFrame(\n    chunk: EncodedVideoChunk,\n    metadata: EncodedVideoChunkMetadata\n  ) {\n    if (!this.outTrackId) {\n      this.outTrackId = this.outFile!.addTrack({\n        avcDecoderConfigRecord: metadata.decoderConfig?.description,\n        height: this.inInfo!.videoTracks[0].track_height,\n        nb_samples: this.inInfo!.videoTracks[0].nb_samples,\n        timescale: this.inInfo!.videoTracks[0].timescale,\n        width: this.inInfo!.videoTracks[0].track_width,\n      });\n    }\n\n    // console.debug(`Encoded frame ${this.framesEncoded}`);\n\n    const buffer = new ArrayBuffer(chunk.byteLength);\n    chunk.copyTo(buffer);\n\n    this.outFile!.addSample(this.outTrackId, buffer, {\n      cts: this.framesEncoded,\n      dts: this.framesEncoded,\n      duration: 1,\n      is_sync: chunk.type === \"key\",\n    });\n\n    this.progressUpdate(this.framesEncoded);\n\n    this.framesEncoded++;\n\n    if (this.framesEncoded === this.expectedFrames) {\n      const buffer = this.outFile!.getBuffer();\n\n      if (buffer.byteLength === 0) {\n        throw Error(\"Output buffer is empty!?\");\n      }\n\n      postMessage({\n        type: VideoWorkerShared.MessageType.FILE_OUT,\n        buffer,\n      } as VideoWorkerShared.FileOutMessage, [buffer]);\n    } else {\n      if (this.samples.length > 0) {\n        // console.debug(\"Encoder not done, queueing next samples for decoding\");\n        this.decodeNextSamples();\n      }\n    }\n  }\n\n  onInError(e: Error) {\n    throw e;\n  }\n\n  handleDecoderError(e: Error) {\n    throw e;\n  }\n\n  handleEncoderError(e: Error) {\n    throw e;\n  }\n}\n","export const SD_TILE_WIDTH = 12 * 3;\nexport const SD_TILE_HEIGHT = 18 * 3;\n\nexport const HD_TILE_WIDTH = 12 * 2;\nexport const HD_TILE_HEIGHT = 18 * 2;\n\nexport const TILES_PER_PAGE = 256;\n\nexport interface FontPack {\n  sd1: Font;\n  sd2: Font;\n  hd1: Font;\n  hd2: Font;\n}\n\nexport class Font {\n  readonly name: string;\n  readonly tiles: ImageBitmap[];\n\n  constructor(name: string, tiles: ImageBitmap[]) {\n    this.name = name;\n    this.tiles = tiles;\n  }\n\n  getTile(index: number): ImageBitmap {\n    return this.tiles[index];\n  }\n\n  static async fromFile(file: File): Promise<Font> {\n    const data = await file.arrayBuffer();\n    const isHd = file.name.includes(\"hd\");\n\n    const tileWidth = isHd ? HD_TILE_WIDTH : SD_TILE_WIDTH;\n    const tileHeight = isHd ? HD_TILE_HEIGHT : SD_TILE_HEIGHT;\n\n    const tiles: ImageBitmap[] = [];\n    for (let tileIndex = 0; tileIndex < TILES_PER_PAGE; tileIndex++) {\n      const pixData = new Uint8ClampedArray(\n        data,\n        tileIndex * tileWidth * tileHeight * 4,\n        tileWidth * tileHeight * 4\n      );\n\n      const imageData = new ImageData(pixData, tileWidth, tileHeight);\n      const imageBitmap = await createImageBitmap(imageData);\n      tiles.push(imageBitmap);\n    }\n\n    return new Font(file.name, tiles);\n  }\n\n  static async fromFiles(files: File[]): Promise<FontPack> {\n    const fonts = files.map((file) => Font.fromFile(file));\n    const fontPack = await Promise.all(fonts);\n\n    return {\n      sd1: fontPack.find(\n        (font) => !font.name.includes(\"_2\") && !font.name.includes(\"hd\")\n      )!,\n      sd2: fontPack.find(\n        (font) => font.name.includes(\"_2\") && !font.name.includes(\"hd\")\n      )!,\n      hd1: fontPack.find(\n        (font) => !font.name.includes(\"_2\") && font.name.includes(\"hd\")\n      )!,\n      hd2: fontPack.find(\n        (font) => font.name.includes(\"_2\") && font.name.includes(\"hd\")\n      )!,\n    };\n  }\n}\n","import { StreamDataView } from \"stream-data-view\";\n\ninterface OsdHeader {\n  magic: string;\n  version: number;\n  config: OsdConfig;\n}\n\ninterface OsdConfig {\n  charWidth: number;\n  charHeight: number;\n  fontWidth: number;\n  fontHeight: number;\n  xOffset: number;\n  yOffset: number;\n  fontVariant: number;\n}\n\ninterface OsdFrame {\n  frameNumber: number;\n  frameSize: number;\n  frameData: Uint16Array;\n}\n\nexport class OsdReader {\n  readonly header: OsdHeader;\n  readonly frames: OsdFrame[] = [];\n\n  constructor(data: ArrayBuffer) {\n    const stream = new StreamDataView(data);\n    this.header = {\n      magic: stream.getNextString(7),\n      version: stream.getNextUint16(),\n      config: {\n        charWidth: stream.getNextUint8(),\n        charHeight: stream.getNextUint8(),\n        fontWidth: stream.getNextUint8(),\n        fontHeight: stream.getNextUint8(),\n        xOffset: stream.getNextUint16(),\n        yOffset: stream.getNextUint16(),\n        fontVariant: stream.getNextUint8(),\n      },\n    };\n\n    if (this.header.config.charWidth === 31) {\n      this.header.config.charWidth = 30;\n    }\n\n    while (stream.getOffset() < data.byteLength) {\n      const frameNumber = stream.getNextUint32();\n      const frameSize = stream.getNextUint32();\n      const frameData = new Uint16Array(data, stream.getOffset(), frameSize);\n      stream.setOffset(stream.getOffset() + frameSize * 2);\n\n      this.frames.push({\n        frameNumber,\n        frameSize,\n        frameData,\n      });\n    }\n  }\n\n  static async fromFile(file: File): Promise<OsdReader> {\n    const data = await file.arrayBuffer();\n    return new OsdReader(data);\n  }\n}\n","/// <reference lib=\"webworker\" />\n\nimport VideoWorkerShared from \"./shared\";\nimport { Processor } from \"./processor\";\nimport {\n  Font,\n  FontPack,\n  TILES_PER_PAGE,\n} from \"./fonts\";\nimport { OsdReader } from \"./osd\";\nimport MP4Box from \"mp4box\";\n\nconst MAX_DISPLAY_X = 60;\nconst MAX_DISPLAY_Y = 22;\n\nexport class VideoWorker {\n  readonly processor: Processor;\n  fontPack?: FontPack;\n  osdReader?: OsdReader;\n\n  lastOsdIndex: number = 0;\n\n  wide: boolean = false;\n  hd: boolean = false;\n  outWidth?: number;\n  outHeight?: number;\n\n  osdCanvas?: OffscreenCanvas;\n  osdCtx?: OffscreenCanvasRenderingContext2D;\n  frameCanvas?: OffscreenCanvas;\n  frameCtx?: OffscreenCanvasRenderingContext2D;\n\n  constructor() {\n    this.processor = new Processor({\n      infoReady: this.infoReady.bind(this),\n      modifyFrame: this.modifyFrame.bind(this),\n      progressInit: this.progressInit.bind(this),\n      progressUpdate: this.progressUpdate.bind(this),\n    });\n\n    addEventListener(\"message\", this.onMessage.bind(this)); // eslint-disable-line no-restricted-globals\n  }\n\n  infoReady(info: MP4Box.ISOFileInfo) {\n    const width = info.videoTracks[0].track_width;\n    const height = info.videoTracks[0].track_height;\n\n    if (width === 1280 && height === 720) {\n      this.wide = true;\n    }\n\n    if (this.osdReader!.header.config.fontWidth === 24) {\n      this.hd = true;\n    }\n\n    let outWidth: number;\n    let outHeight: number;\n    if (this.wide || this.hd) {\n      outWidth = 1280;\n      outHeight = 720;\n    } else {\n      outWidth = width;\n      outHeight = height;\n    }\n\n    this.outWidth = outWidth;\n    this.outHeight = outHeight;\n\n    this.osdCanvas = new OffscreenCanvas(\n      this.osdReader!.header.config.fontWidth * this.osdReader!.header.config.charWidth,\n      this.osdReader!.header.config.fontHeight * this.osdReader!.header.config.charHeight\n    );\n    this.osdCtx = this.osdCanvas.getContext(\"2d\")!;\n\n    this.frameCanvas = new OffscreenCanvas(this.outWidth!, this.outHeight!);\n    this.frameCtx = this.frameCanvas.getContext(\"2d\")!;\n\n    this.processor.processSamples({\n      width: outWidth,\n      height: outHeight,\n    });\n  }\n\n  modifyFrame(frame: VideoFrame, frameIndex: number): VideoFrame {\n    const osdCanvas = this.osdCanvas!;\n    const osdCtx = this.osdCtx!;\n    const frameCanvas = this.frameCanvas!;\n    const frameCtx = this.frameCtx!;\n\n    frameCtx.fillStyle = \"black\";\n    frameCtx.fillRect(0, 0, frameCanvas.width, frameCanvas.height);\n    osdCtx.clearRect(0, 0, osdCanvas.width, osdCanvas.height);\n\n    let frameXOffset: number;\n    if (this.hd || this.wide) {\n      frameXOffset = (this.outWidth! - frame.displayWidth) / 2;\n    } else {\n      frameXOffset = 0;\n    }\n    frameCtx.drawImage(frame, frameXOffset, 0);\n\n    if (this.lastOsdIndex < this.osdReader!.frames.length - 1) {\n      const nextOsdIndex = this.lastOsdIndex + 1;\n      const nextOsdFrame = this.osdReader!.frames[nextOsdIndex];\n\n      if (frameIndex >= nextOsdFrame.frameNumber) {\n        this.lastOsdIndex = nextOsdIndex;\n      }\n    }\n\n    const osdFrame = this.osdReader!.frames[this.lastOsdIndex];\n    for (let y = 0; y < MAX_DISPLAY_Y; y++) {\n      for (let x = 0; x < MAX_DISPLAY_X; x++) {\n        const osdFrameIndex = y + MAX_DISPLAY_Y * x;\n        const osdFrameChar = osdFrame.frameData[osdFrameIndex];\n\n        let font: Font;\n        if (this.hd) {\n          font =\n            osdFrameChar < TILES_PER_PAGE\n              ? this.fontPack!.hd1\n              : this.fontPack!.hd2;\n        } else {\n          font =\n            osdFrameChar < TILES_PER_PAGE\n              ? this.fontPack!.sd1\n              : this.fontPack!.sd2;\n        }\n\n        osdCtx.drawImage(\n          font.getTile(osdFrameChar % TILES_PER_PAGE),\n          x * this.osdReader!.header.config.fontWidth,\n          y * this.osdReader!.header.config.fontHeight\n        );\n      }\n    }\n\n    const osdScale = frameCanvas.height / osdCanvas.height;\n    const osdWidth = osdCanvas.width * osdScale;\n    const osdHeight = osdCanvas.height * osdScale;\n    const osdXOffset = (frameCanvas.width - osdWidth) / 2;\n    const osdYOffset = (frameCanvas.height - osdHeight) / 2;\n\n    frameCtx.drawImage(\n      osdCanvas,\n      osdXOffset,\n      osdYOffset,\n      osdWidth,\n      osdHeight\n    );\n\n    return new VideoFrame(frameCanvas as any, { timestamp: frame.timestamp! });\n  }\n\n  progressInit(expectedFrames: number) {\n    postMessage({\n      type: VideoWorkerShared.MessageType.PROGRESS_INIT,\n      expectedFrames,\n    });\n  }\n\n  progressUpdate(currentFrame?: number, preview?: ImageBitmap) {\n    postMessage({\n      type: VideoWorkerShared.MessageType.PROGRESS_UPDATE,\n      currentFrame,\n      preview,\n    }, [...(preview ? [preview] : [])]);\n  }\n\n  async onMessage(event: MessageEvent<VideoWorkerShared.Message>) {\n    const message = event.data;\n    switch (message.type) {\n      case VideoWorkerShared.MessageType.FILE_IN: {\n        console.debug(\"Hello from the worker!\");\n\n        this.osdReader = await OsdReader.fromFile(message.osdFile);\n        console.debug(\"Got OSD reader\");\n\n        this.fontPack = await Font.fromFiles(message.fontFiles);\n        console.debug(\"Got font pack\");\n\n        console.debug(\"Starting processor...\");\n        this.processor.processFile(message.videoFile);\n        break;\n      }\n\n      default: {\n        throw new Error(\"Unknown message type received\");\n      }\n    }\n  }\n}\n\nnew VideoWorker();\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [16], function() { return __webpack_require__(9287); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n\tvar getter = module && module.__esModule ?\n\t\tfunction() { return module['default']; } :\n\t\tfunction() { return module; };\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"57fd4f51\" + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","__webpack_require__.p = \"/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t287: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkwtfos_configurator\"] = self[\"webpackChunkwtfos_configurator\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn __webpack_require__.e(16).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["MessageType","VideoWorkerShared","avcCBoxToDescription","avcCBox","stream","StreamDataView","undefined","setNextUint8","configurationVersion","AVCProfileIndication","profile_compatibility","AVCLevelIndication","lengthSizeMinusOne","nb_SPS_nalus","i","SPS","length","setNextUint16","j","nalu","nb_PPS_nalus","PPS","ext","getBuffer","Processor","options","decoder","encoder","inFile","inInfo","outFile","expectedFrames","framesDecoded","framesEncoded","queuedForDecode","queuedForEncode","outTrackId","infoReady","modifyFrame","progressInit","progressUpdate","samples","this","MP4Box","onReady","onInInfoReady","bind","onSamples","onInSamples","onError","onInError","close","VideoEncoder","output","handleEncodedFrame","error","handleEncoderError","VideoDecoder","handleDecodedFrame","handleDecoderError","file","reset","reader","getReader","bytesRead","read","done","value","buffer","fileStart","appendBuffer","byteLength","Error","configure","codec","width","height","bitrate","videoTracks","framerate","latencyMode","nb_samples","setExtractionOptions","id","nbSamples","rapAlignement","start","flush","info","codedWidth","track_width","codedHeight","track_height","description","moov","traks","mdia","minf","stbl","stsd","entries","avcC","optimizeForLatency","trackId","user","sample","size","console","warn","number","push","decodeNextSamples","decodeQueueSize","encodeQueueSize","shift","chunk","EncodedVideoChunk","data","duration","Math","floor","timescale","timestamp","dts","type","is_sync","decode","debug","frame","modifiedFrame","encode","keyFrame","createImageBitmap","then","previewBitmap","releaseUsedSamples","metadata","addTrack","avcDecoderConfigRecord","decoderConfig","ArrayBuffer","copyTo","addSample","cts","postMessage","e","TILES_PER_PAGE","Font","name","tiles","index","arrayBuffer","isHd","includes","tileWidth","tileHeight","tileIndex","pixData","Uint8ClampedArray","imageData","ImageData","imageBitmap","files","fonts","map","fromFile","Promise","all","fontPack","sd1","find","font","sd2","hd1","hd2","OsdReader","header","frames","magic","getNextString","version","getNextUint16","config","charWidth","getNextUint8","charHeight","fontWidth","fontHeight","xOffset","yOffset","fontVariant","getOffset","frameNumber","getNextUint32","frameSize","frameData","Uint16Array","setOffset","VideoWorker","processor","osdReader","lastOsdIndex","wide","hd","outWidth","outHeight","osdCanvas","osdCtx","frameCanvas","frameCtx","addEventListener","onMessage","OffscreenCanvas","getContext","processSamples","frameIndex","frameXOffset","fillStyle","fillRect","clearRect","displayWidth","drawImage","nextOsdIndex","osdFrame","y","x","osdFrameIndex","osdFrameChar","getTile","osdScale","osdWidth","osdHeight","osdXOffset","osdYOffset","VideoFrame","currentFrame","preview","event","message","osdFile","fromFiles","fontFiles","processFile","videoFile","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","call","m","__webpack_exports__","O","deferred","result","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","Object","keys","every","key","splice","r","n","getter","__esModule","d","a","definition","o","defineProperty","enumerable","get","f","chunkId","reduce","promises","u","miniCssF","obj","prop","prototype","hasOwnProperty","p","installedChunks","importScripts","chunkLoadingGlobal","self","parentChunkLoadingFunction","moreModules","runtime","pop","next"],"sourceRoot":""}