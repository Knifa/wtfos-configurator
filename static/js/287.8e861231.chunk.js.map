{"version":3,"file":"static/js/287.8e861231.chunk.js","mappings":"uIACoBA,GAAAA,SAAAA,GAAAA,EAAAA,EAAAA,QAAAA,GAAAA,UAAAA,EAAAA,EAAAA,SAAAA,GAAAA,WAAAA,EAAAA,EAAAA,cAAAA,GAAAA,gBAAAA,EAAAA,EAAAA,gBAAAA,GAAAA,kBAAAA,CAAAA,IAAAA,EAAAA,KAAAA,EAAAA,YAAAA,E,CADVC,IAAAA,EAAAA,KAsCV,Q,4BClCA,SAASC,EAAqBC,GAC5B,IAAMC,EAAS,IAAIC,EAAAA,oBAAeC,GAAW,GAE7CF,EAAOG,aAAaJ,EAAQK,sBAC5BJ,EAAOG,aAAaJ,EAAQM,sBAC5BL,EAAOG,aAAaJ,EAAQO,uBAC5BN,EAAOG,aAAaJ,EAAQQ,oBAC5BP,EAAOG,aAAaJ,EAAQS,mBAAR,KAEpBR,EAAOG,aAAaJ,EAAQU,aAAR,KACpB,IAAK,IAAIC,EAAI,EAAGA,EAAIX,EAAQY,IAAIC,OAAQF,IAAK,CAC3CV,EAAOa,cAAcd,EAAQY,IAAID,GAAGE,QACpC,IAAK,IAAIE,EAAI,EAAGA,EAAIf,EAAQY,IAAID,GAAGE,OAAQE,IACzCd,EAAOG,aAAaJ,EAAQY,IAAID,GAAGK,KAAKD,IAI5Cd,EAAOG,aAAaJ,EAAQiB,cAC5B,IAAK,IAAIN,EAAI,EAAGA,EAAIX,EAAQkB,IAAIL,OAAQF,IAAK,CAC3CV,EAAOa,cAAcd,EAAQkB,IAAIP,GAAGE,QACpC,IAAK,IAAIE,EAAI,EAAGA,EAAIf,EAAQkB,IAAIP,GAAGE,OAAQE,IACzCd,EAAOG,aAAaJ,EAAQkB,IAAIP,GAAGK,KAAKD,IAI5C,GAAIf,EAAQmB,IACV,IAAK,IAAIR,EAAI,EAAGA,EAAIX,EAAQmB,IAAIN,OAAQF,IACtCV,EAAOG,aAAaJ,EAAQmB,IAAIR,IAIpC,OAAOV,EAAOmB,YAeT,IAAMC,EAAb,WAkBE,WAAYC,IAA4B,oBAjBxCC,aAiBuC,OAhBvCC,aAgBuC,OAdvCC,YAcuC,OAbvCC,YAauC,OAZvCC,aAYuC,OAVvCC,eAAyB,EAUc,KATvCC,qBAA+B,EASQ,KARvCC,qBAA+B,EAQQ,KAPvCC,gBAOuC,OALvCC,eAKuC,OAJvCC,iBAIuC,OAHvCC,kBAGuC,OAFvCC,oBAEuC,EACrCC,KAAKJ,UAAYV,EAAQU,UACzBI,KAAKH,YAAcX,EAAQW,YAC3BG,KAAKF,aAAeZ,EAAQY,aAC5BE,KAAKD,eAAiBb,EAAQa,eAtBlC,oCAyBE,WACEC,KAAKX,OAASY,EAAAA,aACdD,KAAKX,OAAOa,QAAUF,KAAKG,cAAcC,KAAKJ,MAC9CA,KAAKX,OAAOgB,UAAYL,KAAKM,YAAYF,KAAKJ,MAE9CA,KAAKT,QAAUU,EAAAA,aAEXD,KAAKZ,SACPY,KAAKZ,QAAQmB,QAGfP,KAAKZ,QAAU,IAAIoB,aAAa,CAC9BC,OAAQT,KAAKU,mBAAmBN,KAAKJ,MACrCW,MAAOX,KAAKY,mBAAmBR,KAAKJ,QAGlCA,KAAKb,SACPa,KAAKb,QAAQoB,QAGfP,KAAKb,QAAU,IAAI0B,aAAa,CAC9BJ,OAAQT,KAAKc,mBAAmBV,KAAKJ,MACrCW,MAAOX,KAAKe,mBAAmBX,KAAKJ,UA/C1C,4DAmDE,WAAkBgB,GAAlB,mFACEhB,KAAKiB,QAELjB,KAAKP,qBAAuB,EAC5BO,KAAKN,qBAAuB,EAC5BM,KAAKR,eAAiB,EACtBQ,KAAKL,gBAAa5B,EAEZF,EAASmD,EAAKnD,SACdqD,EAASrD,EAAOsD,YAElBC,EAAY,EAXlB,wBAgBcF,EAAOG,OAhBrB,oBAcMC,EAdN,EAcMA,KACAC,EAfN,EAeMA,OAGED,EAlBR,sDAsBUE,EAASD,EAAMC,QACLC,UAAYL,EAC5BpB,KAAKX,OAAQqC,aAAaF,GAC1BJ,GAAaG,EAAMI,WAzBvB,gEAnDF,mFAgFE,SAAezC,GACb,IAAKc,KAAKV,OACR,MAAM,IAAIsC,MAAM,YAGlB5B,KAAKZ,QAASyC,UAAU,CACtBC,MAAO,cACPC,MAAO7C,EAAQ6C,MACfC,OAAQ9C,EAAQ8C,OAChBC,QAASjC,KAAKV,OAAO4C,YAAY,GAAGD,QACpCE,UAAW,KAGbnC,KAAKR,eAAiBQ,KAAKV,OAAO4C,YAAY,GAAGE,WACjDpC,KAAKN,qBAAuB,EAE5BM,KAAKF,aAAaE,KAAKR,gBAEvBQ,KAAKX,OAAQgD,qBAAqBrC,KAAKV,OAAO4C,YAAY,GAAGI,IAC7DtC,KAAKX,OAAQkD,QACbvC,KAAKX,OAAQmD,UApGjB,2BAuGE,SAAcC,GACZzC,KAAKV,OAASmD,EAEdzC,KAAKb,QAAS0C,UAAU,CACtBC,MAAOW,EAAKP,YAAY,GAAGJ,MAC3BY,WAAYD,EAAKP,YAAY,GAAGS,YAChCC,YAAaH,EAAKP,YAAY,GAAGW,aACjCC,YAAanF,EACVqC,KAAKX,OAAe0D,KAAKC,MAAM,GAAGC,KAAKC,KAAKC,KAAKC,KAAKC,QAAQ,GAAGC,QAItEtD,KAAKJ,UAAU6C,KAnHnB,yBAsHE,SAAYc,EAAkBC,EAAeC,GAAgC,IAAD,YACrDA,GADqD,IAC1E,2BAA8B,CAAC,IAApBC,EAAmB,QACtBC,EAAQ,IAAIC,kBAAkB,CAClCC,KAAMH,EAAOG,KACbC,SAAUC,KAAKC,MAAON,EAAOI,SAAWJ,EAAOO,UAAa,KAC5DC,UAAWH,KAAKC,MAAON,EAAOS,IAAMT,EAAOO,UAAa,KACxDG,KAAMV,EAAOW,QAAU,MAAQ,UAGjCrE,KAAKb,QAASmF,OAAOX,IATmD,iCAtH9E,gCAmIE,SAAmBY,GAAoB,IAAD,OAC9BC,EAAgBxE,KAAKH,YAAa0E,EAAOvE,KAAKP,sBACpD8E,EAAMhE,QAENP,KAAKZ,QAASqF,OAAOD,EAAe,CAAEE,SAAU1E,KAAKP,qBAAuB,KAAO,IAE/EO,KAAKP,qBAAuB,KAAO,GACrCkF,kBAAkBH,GAAeI,MAAK,SAACC,GACrC,EAAK9E,oBAAehC,EAAW8G,MAInC7E,KAAKP,uBAEL+E,EAAcjE,UAjJlB,gCAoJE,SAAmBuE,GACjB,MAAMA,IArJV,gCAwJE,SACEnB,EACAoB,GAEuB,IAAD,EAAjB/E,KAAKL,aACRK,KAAKL,WAAaK,KAAKT,QAASyF,SAAS,CACvCC,uBAAsB,UAAEF,EAASG,qBAAX,aAAE,EAAwBpC,YAChDd,OAAQhC,KAAKV,OAAQ4C,YAAY,GAAGW,aACpCT,WAAYpC,KAAKV,OAAQ4C,YAAY,GAAGE,WACxC6B,UAAWjE,KAAKV,OAAQ4C,YAAY,GAAG+B,UACvClC,MAAO/B,KAAKV,OAAQ4C,YAAY,GAAGS,eAIvC,IAAMnB,EAAS,IAAI2D,YAAYxB,EAAMhC,YAcrC,GAbAgC,EAAMyB,OAAO5D,GAEbxB,KAAKT,QAAS8F,UAAUrF,KAAKL,WAAY6B,EAAQ,CAC/C8D,IAAKtF,KAAKN,qBACVyE,IAAKnE,KAAKN,qBACVoE,SAAU,EACVO,QAAwB,QAAfV,EAAMS,OAGjBpE,KAAKD,eAAeC,KAAKN,sBAEzBM,KAAKN,uBAEDM,KAAKN,uBAAyBM,KAAKR,eAAgB,CACrD,IAAMgC,EAASxB,KAAKT,QAASP,YACvBuG,EAAO,IAAIC,KAAK,CAAChE,GAAS,CAAE4C,KAAM,cAClCqB,EAAMC,IAAIC,gBAAgBJ,GAEhCK,YAAY,CACVxB,KAAM1G,EAAAA,YAAAA,SACNmI,WAAYJ,OA3LpB,gCAgME,SAAmBX,GACjBgB,QAAQnF,MAAMmE,OAjMlB,KC5CaiB,EAAiB,IASjBC,EAAb,WAIE,WAAYC,EAAcC,IAAuB,oBAHxCD,UAGuC,OAFvCC,WAEuC,EAC9ClG,KAAKiG,KAAOA,EACZjG,KAAKkG,MAAQA,EANjB,sCASE,SAAQC,GACN,OAAOnG,KAAKkG,MAAMC,MAVtB,0DAaE,WAAsBnF,GAAtB,uGACqBA,EAAKoF,cAD1B,OACQvC,EADR,OAEQwC,EAAOrF,EAAKiF,KAAKK,SAAS,MAE1BC,EAAYF,EA7BO,GAHA,GAiCnBG,EAAaH,EA7BO,GAHA,GAkCpBH,EAAuB,GACpBO,EAAY,EARvB,YAQ0BA,EAAYV,GARtC,wBASUW,EAAU,IAAIC,kBAClB9C,EACA4C,EAAYF,EAAYC,EAAa,EACrCD,EAAYC,EAAa,GAGrBI,EAAY,IAAIC,UAAUH,EAASH,EAAWC,GAfxD,UAgB8B7B,kBAAkBiC,GAhBhD,QAgBUE,EAhBV,OAiBIZ,EAAMa,KAAKD,GAjBf,QAQsDL,IARtD,gDAoBS,IAAIT,EAAKhF,EAAKiF,KAAMC,IApB7B,4CAbF,iHAoCE,WAAuBc,GAAvB,gFACQC,EAAQD,EAAME,KAAI,SAAClG,GAAD,OAAUgF,EAAKmB,SAASnG,MADlD,SAEyBoG,QAAQC,IAAIJ,GAFrC,cAEQK,EAFR,yBAIS,CACLC,IAAKD,EAASE,MACZ,SAACC,GAAD,OAAWA,EAAKxB,KAAKK,SAAS,QAAUmB,EAAKxB,KAAKK,SAAS,SAE7DoB,IAAKJ,EAASE,MACZ,SAACC,GAAD,OAAUA,EAAKxB,KAAKK,SAAS,QAAUmB,EAAKxB,KAAKK,SAAS,SAE5DqB,IAAKL,EAASE,MACZ,SAACC,GAAD,OAAWA,EAAKxB,KAAKK,SAAS,OAASmB,EAAKxB,KAAKK,SAAS,SAE5DsB,IAAKN,EAASE,MACZ,SAACC,GAAD,OAAUA,EAAKxB,KAAKK,SAAS,OAASmB,EAAKxB,KAAKK,SAAS,WAf/D,2CApCF,8DCSauB,EAAb,WAIE,WAAYhE,IAAoB,oBAHvBiE,YAGsB,OAFtBC,OAAqB,GAG5B,IAAMlK,EAAS,IAAIC,EAAAA,eAAe+F,GAmBlC,IAlBA7D,KAAK8H,OAAS,CACZE,MAAOnK,EAAOoK,cAAc,GAC5BC,QAASrK,EAAOsK,gBAChBC,OAAQ,CACNC,UAAWxK,EAAOyK,eAClBC,WAAY1K,EAAOyK,eACnBE,UAAW3K,EAAOyK,eAClBG,WAAY5K,EAAOyK,eACnBI,QAAS7K,EAAOsK,gBAChBQ,QAAS9K,EAAOsK,gBAChBS,YAAa/K,EAAOyK,iBAIa,KAAjCtI,KAAK8H,OAAOM,OAAOC,YACrBrI,KAAK8H,OAAOM,OAAOC,UAAY,IAG1BxK,EAAOgL,YAAchF,EAAKlC,YAAY,CAC3C,IAAMmH,EAAcjL,EAAOkL,gBACrBC,EAAYnL,EAAOkL,gBACnBE,EAAY,IAAIC,YAAYrF,EAAMhG,EAAOgL,YAAaG,GAC5DnL,EAAOsL,UAAUtL,EAAOgL,YAA0B,EAAZG,GAEtChJ,KAAK+H,OAAOhB,KAAK,CACf+B,YAAAA,EACAE,UAAAA,EACAC,UAAAA,KAjCR,+EAsCE,WAAsBjI,GAAtB,uFACqBA,EAAKoF,cAD1B,cACQvC,EADR,yBAES,IAAIgE,EAAUhE,IAFvB,2CAtCF,8DCTauF,EAAb,WAiBE,cAAe,oBAhBNC,eAgBK,OAfd/B,cAec,OAddgC,eAcc,OAZdC,aAAuB,EAYT,KAVdC,MAAgB,EAUF,KATdC,IAAc,EASA,KARdC,cAQc,OAPdC,eAOc,OALdC,eAKc,OAJdC,YAIc,OAHdC,iBAGc,OAFdC,cAEc,EACZ/J,KAAKqJ,UAAY,IAAIpK,EAAU,CAC7BW,UAAWI,KAAKJ,UAAUQ,KAAKJ,MAC/BH,YAAaG,KAAKH,YAAYO,KAAKJ,MACnCF,aAAcE,KAAKF,aAAaM,KAAKJ,MACrCD,eAAgBC,KAAKD,eAAeK,KAAKJ,QAG3CgK,iBAAiB,UAAWhK,KAAKiK,UAAU7J,KAAKJ,OAzBpD,wCA4BE,SAAUyC,GACR,IAaIiH,EACAC,EAdE5H,EAAQU,EAAKP,YAAY,GAAGS,YAC5BX,EAASS,EAAKP,YAAY,GAAGW,aAEnCiD,QAAQoE,IAAIlK,KAAKsJ,UAAWxB,OAAOM,QAErB,OAAVrG,GAA6B,MAAXC,IACpBhC,KAAKwJ,MAAO,GAGkC,KAA5CxJ,KAAKsJ,UAAWxB,OAAOM,OAAOI,YAChCxI,KAAKyJ,IAAK,GAKRzJ,KAAKwJ,MAAQxJ,KAAKyJ,IACpBC,EAAW,KACXC,EAAY,MAEZD,EAAW3H,EACX4H,EAAY3H,GAGdhC,KAAK0J,SAAWA,EAChB1J,KAAK2J,UAAYA,EAEjB3J,KAAK4J,UAAY,IAAIO,gBACnBnK,KAAKsJ,UAAWxB,OAAOM,OAAOI,UAAYxI,KAAKsJ,UAAWxB,OAAOM,OAAOC,UACxErI,KAAKsJ,UAAWxB,OAAOM,OAAOK,WAAazI,KAAKsJ,UAAWxB,OAAOM,OAAOG,YAE3EvI,KAAK6J,OAAS7J,KAAK4J,UAAUQ,WAAW,MAExCpK,KAAK8J,YAAc,IAAIK,gBAAgBnK,KAAK0J,SAAW1J,KAAK2J,WAC5D3J,KAAK+J,SAAW/J,KAAK8J,YAAYM,WAAW,MAE5CpK,KAAKqJ,UAAUgB,eAAe,CAC5BtI,MAAO2H,EACP1H,OAAQ2H,MAlEd,yBAsEE,SAAYpF,EAAmB+F,GAC7B,IASIC,EATEX,EAAY5J,KAAK4J,UACjBC,EAAS7J,KAAK6J,OACdC,EAAc9J,KAAK8J,YACnBC,EAAW/J,KAAK+J,SActB,GAZAA,EAASS,UAAY,QACrBT,EAASU,SAAS,EAAG,EAAGX,EAAY/H,MAAO+H,EAAY9H,QACvD6H,EAAOa,UAAU,EAAG,EAAGd,EAAU7H,MAAO6H,EAAU5H,QAIhDuI,EADEvK,KAAKyJ,IAAMzJ,KAAKwJ,MACFxJ,KAAK0J,SAAYnF,EAAMoG,cAAgB,EAExC,EAEjBZ,EAASa,UAAUrG,EAAOgG,EAAc,GAEpCvK,KAAKuJ,aAAevJ,KAAKsJ,UAAWvB,OAAOtJ,OAAS,EAAG,CACzD,IAAMoM,EAAe7K,KAAKuJ,aAAe,EAGrCe,GAFiBtK,KAAKsJ,UAAWvB,OAAO8C,GAEb/B,cAC7B9I,KAAKuJ,aAAesB,GAKxB,IADA,IAAMC,EAAW9K,KAAKsJ,UAAWvB,OAAO/H,KAAKuJ,cACpCwB,EAAI,EAAGA,EApGE,GAoGiBA,IACjC,IAAK,IAAIC,EAAI,EAAGA,EAtGA,GAsGmBA,IAAK,CACtC,IAAMC,EAAgBF,EAtGR,GAsG4BC,EACpCE,EAAeJ,EAAS7B,UAAUgC,GAEpCxD,OAAU,EAEZA,EADEzH,KAAKyJ,GAELyB,EAAenF,EACX/F,KAAKsH,SAAUK,IACf3H,KAAKsH,SAAUM,IAGnBsD,EAAenF,EACX/F,KAAKsH,SAAUC,IACfvH,KAAKsH,SAAUI,IAGvBmC,EAAOe,UACLnD,EAAK0D,QAAQD,EAAenF,GAC5BiF,EAAIhL,KAAKsJ,UAAWxB,OAAOM,OAAOI,UAClCuC,EAAI/K,KAAKsJ,UAAWxB,OAAOM,OAAOK,YAKxC,IAAM2C,EAAWtB,EAAY9H,OAAS4H,EAAU5H,OAC1CqJ,EAAWzB,EAAU7H,MAAQqJ,EAC7BE,EAAY1B,EAAU5H,OAASoJ,EAC/BG,GAAczB,EAAY/H,MAAQsJ,GAAY,EAC9CG,GAAc1B,EAAY9H,OAASsJ,GAAa,EAUtD,OARAvB,EAASa,UACPhB,EACA2B,EACAC,EACAH,EACAC,GAGK,IAAIG,WAAW3B,EAAoB,CAAE5F,UAAWK,EAAML,cA1IjE,0BA6IE,SAAa1E,GACXoG,YAAY,CACVxB,KAAM1G,EAAAA,YAAAA,cACN8B,eAAAA,MAhJN,4BAoJE,SAAekM,EAAuBC,GACpC/F,YAAY,CACVxB,KAAM1G,EAAAA,YAAAA,gBACNgO,aAAAA,EACAC,QAAAA,IAHS,OAIHA,EAAU,CAACA,GAAW,OAzJlC,0DA4JE,WAAgBC,GAAhB,uEACQC,EAAUD,EAAM/H,KADxB,KAEUgI,EAAQzH,KAFlB,cAGS1G,EAAAA,YAAAA,QAHT,yBAIMoI,QAAQgG,MAAM,0BAJpB,SAM6BjE,EAAUV,SAAS0E,EAAQE,SANxD,cAMM/L,KAAKsJ,UANX,OAOMxD,QAAQgG,MAAM,kBAPpB,UAS4B9F,EAAKgG,UAAUH,EAAQI,WATnD,eASMjM,KAAKsH,SATX,OAUMxB,QAAQgG,MAAM,iBAEdhG,QAAQgG,MAAM,yBACd9L,KAAKqJ,UAAU6C,YAAYL,EAAQM,WAbzC,mCAkBY,IAAIvK,MAAM,iCAlBtB,iDA5JF,8DAoLA,IAAIwH,IClMAgD,EAA2B,GAG/B,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBvO,IAAjBwO,EACH,OAAOA,EAAaC,QAGrB,IAAIC,EAASL,EAAyBE,GAAY,CAGjDE,QAAS,IAOV,OAHAE,EAAoBJ,GAAUK,KAAKF,EAAOD,QAASC,EAAQA,EAAOD,QAASH,GAGpEI,EAAOD,QAIfH,EAAoBO,EAAIF,EAGxBL,EAAoBrB,EAAI,WAGvB,IAAI6B,EAAsBR,EAAoBS,OAAE/O,EAAW,CAAC,KAAK,WAAa,OAAOsO,EAAoB,SAEzG,OADAQ,EAAsBR,EAAoBS,EAAED,I,WChC7C,IAAIE,EAAW,GACfV,EAAoBS,EAAI,SAASE,EAAQC,EAAUC,EAAIC,GACtD,IAAGF,EAAH,CAMA,IAAIG,EAAeC,EAAAA,EACnB,IAAS9O,EAAI,EAAGA,EAAIwO,EAAStO,OAAQF,IAAK,CACrC0O,EAAWF,EAASxO,GAAG,GACvB2O,EAAKH,EAASxO,GAAG,GACjB4O,EAAWJ,EAASxO,GAAG,GAE3B,IAJA,IAGI+O,GAAY,EACP3O,EAAI,EAAGA,EAAIsO,EAASxO,OAAQE,MACpB,EAAXwO,GAAsBC,GAAgBD,IAAaI,OAAOC,KAAKnB,EAAoBS,GAAGW,OAAM,SAASC,GAAO,OAAOrB,EAAoBS,EAAEY,GAAKT,EAAStO,OAC3JsO,EAASU,OAAOhP,IAAK,IAErB2O,GAAY,EACTH,EAAWC,IAAcA,EAAeD,IAG7C,GAAGG,EAAW,CACbP,EAASY,OAAOpP,IAAK,GACrB,IAAIqP,EAAIV,SACEnP,IAAN6P,IAAiBZ,EAASY,IAGhC,OAAOZ,EAzBNG,EAAWA,GAAY,EACvB,IAAI,IAAI5O,EAAIwO,EAAStO,OAAQF,EAAI,GAAKwO,EAASxO,EAAI,GAAG,GAAK4O,EAAU5O,IAAKwO,EAASxO,GAAKwO,EAASxO,EAAI,GACrGwO,EAASxO,GAAK,CAAC0O,EAAUC,EAAIC,I,GCJ/Bd,EAAoBwB,EAAI,SAASpB,GAChC,IAAIqB,EAASrB,GAAUA,EAAOsB,WAC7B,WAAa,OAAOtB,EAAgB,SACpC,WAAa,OAAOA,GAErB,OADAJ,EAAoB2B,EAAEF,EAAQ,CAAEG,EAAGH,IAC5BA,GCLRzB,EAAoB2B,EAAI,SAASxB,EAAS0B,GACzC,IAAI,IAAIR,KAAOQ,EACX7B,EAAoB8B,EAAED,EAAYR,KAASrB,EAAoB8B,EAAE3B,EAASkB,IAC5EH,OAAOa,eAAe5B,EAASkB,EAAK,CAAEW,YAAY,EAAMC,IAAKJ,EAAWR,MCJ3ErB,EAAoBkC,EAAI,GAGxBlC,EAAoBvH,EAAI,SAAS0J,GAChC,OAAOpH,QAAQC,IAAIkG,OAAOC,KAAKnB,EAAoBkC,GAAGE,QAAO,SAASC,EAAUhB,GAE/E,OADArB,EAAoBkC,EAAEb,GAAKc,EAASE,GAC7BA,IACL,MCNJrC,EAAoBsC,EAAI,SAASH,GAEhC,MAAO,aAAeA,EAAf,sBCFRnC,EAAoBuC,SAAW,SAASJ,KCDxCnC,EAAoB8B,EAAI,SAASU,EAAKC,GAAQ,OAAOvB,OAAOwB,UAAUC,eAAerC,KAAKkC,EAAKC,ICA/FzC,EAAoB4C,EAAI,I,WCIxB,IAAIC,EAAkB,CACrB,IAAK,GAkBN7C,EAAoBkC,EAAEhQ,EAAI,SAASiQ,EAASE,GAEvCQ,EAAgBV,IAElBW,cAAc9C,EAAoB4C,EAAI5C,EAAoBsC,EAAEH,KAK/D,IAAIY,EAAqBC,KAAqC,+BAAIA,KAAqC,gCAAK,GACxGC,EAA6BF,EAAmBrI,KAAK3G,KAAKgP,GAC9DA,EAAmBrI,KAzBA,SAASlD,GAC3B,IAAIoJ,EAAWpJ,EAAK,GAChB0L,EAAc1L,EAAK,GACnB2L,EAAU3L,EAAK,GACnB,IAAI,IAAIyI,KAAYiD,EAChBlD,EAAoB8B,EAAEoB,EAAajD,KACrCD,EAAoBO,EAAEN,GAAYiD,EAAYjD,IAIhD,IADGkD,GAASA,EAAQnD,GACdY,EAASxO,QACdyQ,EAAgBjC,EAASwC,OAAS,EACnCH,EAA2BzL,I,cCrB5B,IAAI6L,EAAOrD,EAAoBrB,EAC/BqB,EAAoBrB,EAAI,WACvB,OAAOqB,EAAoBvH,EAAE,IAAIF,KAAK8K,I,GCDbrD,EAAoBrB,I","sources":["features/osd-overlay/video-worker/shared.ts","features/osd-overlay/video-worker/processor.ts","features/osd-overlay/video-worker/fonts.ts","features/osd-overlay/video-worker/osd.ts","features/osd-overlay/video-worker/worker.ts","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/compat get default export","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["namespace VideoWorkerShared {\n  export const enum MessageType {\n    FILE_IN,\n    FILE_OUT,\n    PROGRESS_INIT,\n    PROGRESS_UPDATE,\n  }\n\n  export interface FileInMessage {\n    type: MessageType.FILE_IN;\n    fontFiles: File[];\n    osdFile: File;\n    videoFile: File;\n  }\n\n  export interface FileOutMessage {\n    type: MessageType.FILE_OUT;\n    blobString: string;\n  }\n\n  export interface ProgressInitMessage {\n    type: MessageType.PROGRESS_INIT;\n    expectedFrames: number;\n  }\n\n  export interface ProgressUpdateMessage {\n    type: MessageType.PROGRESS_UPDATE;\n    currentFrame?: number;\n    preview?: ImageBitmap;\n  }\n\n  export type Message =\n    | FileInMessage\n    | FileOutMessage\n    | ProgressInitMessage\n    | ProgressUpdateMessage;\n}\n\nexport default VideoWorkerShared;\n","import MP4Box from \"mp4box\";\nimport VideoWorkerShared from \"./shared\";\nimport { StreamDataView } from \"stream-data-view\";\n\nfunction avcCBoxToDescription(avcCBox: any): ArrayBuffer {\n  const stream = new StreamDataView(undefined, true);\n\n  stream.setNextUint8(avcCBox.configurationVersion);\n  stream.setNextUint8(avcCBox.AVCProfileIndication);\n  stream.setNextUint8(avcCBox.profile_compatibility);\n  stream.setNextUint8(avcCBox.AVCLevelIndication);\n  stream.setNextUint8(avcCBox.lengthSizeMinusOne + (63 << 2));\n\n  stream.setNextUint8(avcCBox.nb_SPS_nalus + (7 << 5));\n  for (let i = 0; i < avcCBox.SPS.length; i++) {\n    stream.setNextUint16(avcCBox.SPS[i].length);\n    for (let j = 0; j < avcCBox.SPS[i].length; j++) {\n      stream.setNextUint8(avcCBox.SPS[i].nalu[j]);\n    }\n  }\n\n  stream.setNextUint8(avcCBox.nb_PPS_nalus);\n  for (let i = 0; i < avcCBox.PPS.length; i++) {\n    stream.setNextUint16(avcCBox.PPS[i].length);\n    for (let j = 0; j < avcCBox.PPS[i].length; j++) {\n      stream.setNextUint8(avcCBox.PPS[i].nalu[j]);\n    }\n  }\n\n  if (avcCBox.ext) {\n    for (let i = 0; i < avcCBox.ext.length; i++) {\n      stream.setNextUint8(avcCBox.ext[i]);\n    }\n  }\n\n  return stream.getBuffer();\n}\n\ntype InfoReadyCallback = (info: MP4Box.ISOFileInfo) => void;\ntype ModifyFrameCallback = (frame: VideoFrame, index: number) => VideoFrame;\ntype ProgressInitCallback = (total: number) => void;\ntype ProgressCallback = (processed?: number, preview?: ImageBitmap) => void;\n\nexport interface ProcessorOptions {\n  infoReady: InfoReadyCallback;\n  modifyFrame: ModifyFrameCallback;\n  progressInit: ProgressInitCallback;\n  progressUpdate: ProgressCallback;\n}\n\nexport class Processor {\n  decoder?: VideoDecoder;\n  encoder?: VideoEncoder;\n\n  inFile?: MP4Box.ISOFile;\n  inInfo?: MP4Box.ISOFileInfo;\n  outFile?: MP4Box.ISOFile;\n\n  expectedFrames: number = 0;\n  currentDecodingFrame: number = 0;\n  currentEncodingFrame: number = 0;\n  outTrackId?: number;\n\n  infoReady: InfoReadyCallback;\n  modifyFrame: ModifyFrameCallback;\n  progressInit: ProgressInitCallback;\n  progressUpdate: ProgressCallback;\n\n  constructor(options: ProcessorOptions) {\n    this.infoReady = options.infoReady;\n    this.modifyFrame = options.modifyFrame;\n    this.progressInit = options.progressInit;\n    this.progressUpdate = options.progressUpdate;\n  }\n\n  reset() {\n    this.inFile = MP4Box.createFile();\n    this.inFile.onReady = this.onInInfoReady.bind(this);\n    this.inFile.onSamples = this.onInSamples.bind(this);\n\n    this.outFile = MP4Box.createFile();\n\n    if (this.encoder) {\n      this.encoder.close();\n    }\n\n    this.encoder = new VideoEncoder({\n      output: this.handleEncodedFrame.bind(this),\n      error: this.handleEncoderError.bind(this),\n    });\n\n    if (this.decoder) {\n      this.decoder.close();\n    }\n\n    this.decoder = new VideoDecoder({\n      output: this.handleDecodedFrame.bind(this),\n      error: this.handleDecoderError.bind(this),\n    });\n  }\n\n  async processFile(file: File) {\n    this.reset();\n\n    this.currentDecodingFrame = 0;\n    this.currentEncodingFrame = 0;\n    this.expectedFrames = 0;\n    this.outTrackId = undefined;\n\n    const stream = file.stream();\n    const reader = stream.getReader();\n\n    let bytesRead = 0;\n    while (true) { // eslint-disable-line no-constant-condition\n      const {\n        done,\n        value,\n      } = await reader.read();\n\n      if (done) {\n        break;\n      }\n\n      const buffer = value.buffer;\n      (buffer as any).fileStart = bytesRead;\n      this.inFile!.appendBuffer(buffer);\n      bytesRead += value.byteLength;\n    }\n  }\n\n  processSamples(options: { width: number; height: number }) {\n    if (!this.inInfo) {\n      throw new Error(\"No info?\");\n    }\n\n    this.encoder!.configure({\n      codec: \"avc1.42003d\",\n      width: options.width,\n      height: options.height,\n      bitrate: this.inInfo.videoTracks[0].bitrate,\n      framerate: 60,\n    });\n\n    this.expectedFrames = this.inInfo.videoTracks[0].nb_samples;\n    this.currentEncodingFrame = 0;\n\n    this.progressInit(this.expectedFrames);\n\n    this.inFile!.setExtractionOptions(this.inInfo.videoTracks[0].id);\n    this.inFile!.start();\n    this.inFile!.flush();\n  }\n\n  onInInfoReady(info: MP4Box.ISOFileInfo) {\n    this.inInfo = info;\n\n    this.decoder!.configure({\n      codec: info.videoTracks[0].codec,\n      codedWidth: info.videoTracks[0].track_width,\n      codedHeight: info.videoTracks[0].track_height,\n      description: avcCBoxToDescription(\n        (this.inFile as any).moov.traks[0].mdia.minf.stbl.stsd.entries[0].avcC\n      ),\n    });\n\n    this.infoReady(info);\n  }\n\n  onInSamples(trackId: unknown, user: unknown, samples: MP4Box.VideoSample[]) {\n    for (const sample of samples) {\n      const chunk = new EncodedVideoChunk({\n        data: sample.data,\n        duration: Math.floor((sample.duration / sample.timescale) * 1_000_000),\n        timestamp: Math.floor((sample.dts / sample.timescale) * 1_000_000),\n        type: sample.is_sync ? \"key\" : \"delta\",\n      });\n\n      this.decoder!.decode(chunk);\n    }\n  }\n\n  handleDecodedFrame(frame: VideoFrame) {\n    const modifiedFrame = this.modifyFrame!(frame, this.currentDecodingFrame);\n    frame.close();\n\n    this.encoder!.encode(modifiedFrame, { keyFrame: this.currentDecodingFrame % 60 === 0 });\n\n    if (this.currentDecodingFrame % 60 === 0) {\n      createImageBitmap(modifiedFrame).then((previewBitmap) => {\n        this.progressUpdate(undefined, previewBitmap);\n      });\n    }\n\n    this.currentDecodingFrame++;\n\n    modifiedFrame.close();\n  }\n\n  handleDecoderError(e: Error) {\n    throw e;\n  }\n\n  handleEncodedFrame(\n    chunk: EncodedVideoChunk,\n    metadata: EncodedVideoChunkMetadata\n  ) {\n    if (!this.outTrackId) {\n      this.outTrackId = this.outFile!.addTrack({\n        avcDecoderConfigRecord: metadata.decoderConfig?.description,\n        height: this.inInfo!.videoTracks[0].track_height,\n        nb_samples: this.inInfo!.videoTracks[0].nb_samples,\n        timescale: this.inInfo!.videoTracks[0].timescale,\n        width: this.inInfo!.videoTracks[0].track_width,\n      });\n    }\n\n    const buffer = new ArrayBuffer(chunk.byteLength);\n    chunk.copyTo(buffer);\n\n    this.outFile!.addSample(this.outTrackId, buffer, {\n      cts: this.currentEncodingFrame,\n      dts: this.currentEncodingFrame,\n      duration: 1,\n      is_sync: chunk.type === \"key\",\n    });\n\n    this.progressUpdate(this.currentEncodingFrame);\n\n    this.currentEncodingFrame++;\n\n    if (this.currentEncodingFrame === this.expectedFrames) {\n      const buffer = this.outFile!.getBuffer();\n      const blob = new Blob([buffer], { type: \"video/mp4\" });\n      const url = URL.createObjectURL(blob);\n\n      postMessage({\n        type: VideoWorkerShared.MessageType.FILE_OUT,\n        blobString: url,\n      } as VideoWorkerShared.FileOutMessage);\n    }\n  }\n\n  handleEncoderError(e: Error) {\n    console.error(e);\n  }\n}\n","export const SD_TILE_WIDTH = 12 * 3;\nexport const SD_TILE_HEIGHT = 18 * 3;\n\nexport const HD_TILE_WIDTH = 12 * 2;\nexport const HD_TILE_HEIGHT = 18 * 2;\n\nexport const TILES_PER_PAGE = 256;\n\nexport interface FontPack {\n  sd1: Font;\n  sd2: Font;\n  hd1: Font;\n  hd2: Font;\n}\n\nexport class Font {\n  readonly name: string;\n  readonly tiles: ImageBitmap[];\n\n  constructor(name: string, tiles: ImageBitmap[]) {\n    this.name = name;\n    this.tiles = tiles;\n  }\n\n  getTile(index: number): ImageBitmap {\n    return this.tiles[index];\n  }\n\n  static async fromFile(file: File): Promise<Font> {\n    const data = await file.arrayBuffer();\n    const isHd = file.name.includes(\"hd\");\n\n    const tileWidth = isHd ? HD_TILE_WIDTH : SD_TILE_WIDTH;\n    const tileHeight = isHd ? HD_TILE_HEIGHT : SD_TILE_HEIGHT;\n\n    const tiles: ImageBitmap[] = [];\n    for (let tileIndex = 0; tileIndex < TILES_PER_PAGE; tileIndex++) {\n      const pixData = new Uint8ClampedArray(\n        data,\n        tileIndex * tileWidth * tileHeight * 4,\n        tileWidth * tileHeight * 4\n      );\n\n      const imageData = new ImageData(pixData, tileWidth, tileHeight);\n      const imageBitmap = await createImageBitmap(imageData);\n      tiles.push(imageBitmap);\n    }\n\n    return new Font(file.name, tiles);\n  }\n\n  static async fromFiles(files: File[]): Promise<FontPack> {\n    const fonts = files.map((file) => Font.fromFile(file));\n    const fontPack = await Promise.all(fonts);\n\n    return {\n      sd1: fontPack.find(\n        (font) => !font.name.includes(\"_2\") && !font.name.includes(\"hd\")\n      )!,\n      sd2: fontPack.find(\n        (font) => font.name.includes(\"_2\") && !font.name.includes(\"hd\")\n      )!,\n      hd1: fontPack.find(\n        (font) => !font.name.includes(\"_2\") && font.name.includes(\"hd\")\n      )!,\n      hd2: fontPack.find(\n        (font) => font.name.includes(\"_2\") && font.name.includes(\"hd\")\n      )!,\n    };\n  }\n}\n","import { StreamDataView } from \"stream-data-view\";\n\ninterface OsdHeader {\n  magic: string;\n  version: number;\n  config: OsdConfig;\n}\n\ninterface OsdConfig {\n  charWidth: number;\n  charHeight: number;\n  fontWidth: number;\n  fontHeight: number;\n  xOffset: number;\n  yOffset: number;\n  fontVariant: number;\n}\n\ninterface OsdFrame {\n  frameNumber: number;\n  frameSize: number;\n  frameData: Uint16Array;\n}\n\nexport class OsdReader {\n  readonly header: OsdHeader;\n  readonly frames: OsdFrame[] = [];\n\n  constructor(data: ArrayBuffer) {\n    const stream = new StreamDataView(data);\n    this.header = {\n      magic: stream.getNextString(7),\n      version: stream.getNextUint16(),\n      config: {\n        charWidth: stream.getNextUint8(),\n        charHeight: stream.getNextUint8(),\n        fontWidth: stream.getNextUint8(),\n        fontHeight: stream.getNextUint8(),\n        xOffset: stream.getNextUint16(),\n        yOffset: stream.getNextUint16(),\n        fontVariant: stream.getNextUint8(),\n      },\n    };\n\n    if (this.header.config.charWidth === 31) {\n      this.header.config.charWidth = 30;\n    }\n\n    while (stream.getOffset() < data.byteLength) {\n      const frameNumber = stream.getNextUint32();\n      const frameSize = stream.getNextUint32();\n      const frameData = new Uint16Array(data, stream.getOffset(), frameSize);\n      stream.setOffset(stream.getOffset() + frameSize * 2);\n\n      this.frames.push({\n        frameNumber,\n        frameSize,\n        frameData,\n      });\n    }\n  }\n\n  static async fromFile(file: File): Promise<OsdReader> {\n    const data = await file.arrayBuffer();\n    return new OsdReader(data);\n  }\n}\n","/// <reference lib=\"webworker\" />\n\nimport VideoWorkerShared from \"./shared\";\nimport { Processor } from \"./processor\";\nimport {\n  Font,\n  FontPack,\n  TILES_PER_PAGE,\n} from \"./fonts\";\nimport { OsdReader } from \"./osd\";\nimport MP4Box from \"mp4box\";\n\nconst MAX_DISPLAY_X = 60;\nconst MAX_DISPLAY_Y = 22;\n\nexport class VideoWorker {\n  readonly processor: Processor;\n  fontPack?: FontPack;\n  osdReader?: OsdReader;\n\n  lastOsdIndex: number = 0;\n\n  wide: boolean = false;\n  hd: boolean = false;\n  outWidth?: number;\n  outHeight?: number;\n\n  osdCanvas?: OffscreenCanvas;\n  osdCtx?: OffscreenCanvasRenderingContext2D;\n  frameCanvas?: OffscreenCanvas;\n  frameCtx?: OffscreenCanvasRenderingContext2D;\n\n  constructor() {\n    this.processor = new Processor({\n      infoReady: this.infoReady.bind(this),\n      modifyFrame: this.modifyFrame.bind(this),\n      progressInit: this.progressInit.bind(this),\n      progressUpdate: this.progressUpdate.bind(this),\n    });\n\n    addEventListener(\"message\", this.onMessage.bind(this)); // eslint-disable-line no-restricted-globals\n  }\n\n  infoReady(info: MP4Box.ISOFileInfo) {\n    const width = info.videoTracks[0].track_width;\n    const height = info.videoTracks[0].track_height;\n\n    console.log(this.osdReader!.header.config);\n\n    if (width === 1280 && height === 720) {\n      this.wide = true;\n    }\n\n    if (this.osdReader!.header.config.fontWidth === 24) {\n      this.hd = true;\n    }\n\n    let outWidth: number;\n    let outHeight: number;\n    if (this.wide || this.hd) {\n      outWidth = 1280;\n      outHeight = 720;\n    } else {\n      outWidth = width;\n      outHeight = height;\n    }\n\n    this.outWidth = outWidth;\n    this.outHeight = outHeight;\n\n    this.osdCanvas = new OffscreenCanvas(\n      this.osdReader!.header.config.fontWidth * this.osdReader!.header.config.charWidth,\n      this.osdReader!.header.config.fontHeight * this.osdReader!.header.config.charHeight\n    );\n    this.osdCtx = this.osdCanvas.getContext(\"2d\")!;\n\n    this.frameCanvas = new OffscreenCanvas(this.outWidth!, this.outHeight!);\n    this.frameCtx = this.frameCanvas.getContext(\"2d\")!;\n\n    this.processor.processSamples({\n      width: outWidth,\n      height: outHeight,\n    });\n  }\n\n  modifyFrame(frame: VideoFrame, frameIndex: number): VideoFrame {\n    const osdCanvas = this.osdCanvas!;\n    const osdCtx = this.osdCtx!;\n    const frameCanvas = this.frameCanvas!;\n    const frameCtx = this.frameCtx!;\n\n    frameCtx.fillStyle = \"black\";\n    frameCtx.fillRect(0, 0, frameCanvas.width, frameCanvas.height);\n    osdCtx.clearRect(0, 0, osdCanvas.width, osdCanvas.height);\n\n    let frameXOffset: number;\n    if (this.hd || this.wide) {\n      frameXOffset = (this.outWidth! - frame.displayWidth) / 2;\n    } else {\n      frameXOffset = 0;\n    }\n    frameCtx.drawImage(frame, frameXOffset, 0);\n\n    if (this.lastOsdIndex < this.osdReader!.frames.length - 1) {\n      const nextOsdIndex = this.lastOsdIndex + 1;\n      const nextOsdFrame = this.osdReader!.frames[nextOsdIndex];\n\n      if (frameIndex >= nextOsdFrame.frameNumber) {\n        this.lastOsdIndex = nextOsdIndex;\n      }\n    }\n\n    const osdFrame = this.osdReader!.frames[this.lastOsdIndex];\n    for (let y = 0; y < MAX_DISPLAY_Y; y++) {\n      for (let x = 0; x < MAX_DISPLAY_X; x++) {\n        const osdFrameIndex = y + MAX_DISPLAY_Y * x;\n        const osdFrameChar = osdFrame.frameData[osdFrameIndex];\n\n        let font: Font;\n        if (this.hd) {\n          font =\n            osdFrameChar < TILES_PER_PAGE\n              ? this.fontPack!.hd1\n              : this.fontPack!.hd2;\n        } else {\n          font =\n            osdFrameChar < TILES_PER_PAGE\n              ? this.fontPack!.sd1\n              : this.fontPack!.sd2;\n        }\n\n        osdCtx.drawImage(\n          font.getTile(osdFrameChar % TILES_PER_PAGE),\n          x * this.osdReader!.header.config.fontWidth,\n          y * this.osdReader!.header.config.fontHeight\n        );\n      }\n    }\n\n    const osdScale = frameCanvas.height / osdCanvas.height;\n    const osdWidth = osdCanvas.width * osdScale;\n    const osdHeight = osdCanvas.height * osdScale;\n    const osdXOffset = (frameCanvas.width - osdWidth) / 2;\n    const osdYOffset = (frameCanvas.height - osdHeight) / 2;\n\n    frameCtx.drawImage(\n      osdCanvas,\n      osdXOffset,\n      osdYOffset,\n      osdWidth,\n      osdHeight\n    );\n\n    return new VideoFrame(frameCanvas as any, { timestamp: frame.timestamp! });\n  }\n\n  progressInit(expectedFrames: number) {\n    postMessage({\n      type: VideoWorkerShared.MessageType.PROGRESS_INIT,\n      expectedFrames,\n    });\n  }\n\n  progressUpdate(currentFrame?: number, preview?: ImageBitmap) {\n    postMessage({\n      type: VideoWorkerShared.MessageType.PROGRESS_UPDATE,\n      currentFrame,\n      preview,\n    }, [...(preview ? [preview] : [])]);\n  }\n\n  async onMessage(event: MessageEvent<VideoWorkerShared.Message>) {\n    const message = event.data;\n    switch (message.type) {\n      case VideoWorkerShared.MessageType.FILE_IN: {\n        console.debug(\"Hello from the worker!\");\n\n        this.osdReader = await OsdReader.fromFile(message.osdFile);\n        console.debug(\"Got OSD reader\");\n\n        this.fontPack = await Font.fromFiles(message.fontFiles);\n        console.debug(\"Got font pack\");\n\n        console.debug(\"Starting processor...\");\n        this.processor.processFile(message.videoFile);\n        break;\n      }\n\n      default: {\n        throw new Error(\"Unknown message type received\");\n      }\n    }\n  }\n}\n\nnew VideoWorker();\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [16], function() { return __webpack_require__(9287); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n\tvar getter = module && module.__esModule ?\n\t\tfunction() { return module['default']; } :\n\t\tfunction() { return module; };\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"57fd4f51\" + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","__webpack_require__.p = \"/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t287: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkwtfos_configurator\"] = self[\"webpackChunkwtfos_configurator\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn __webpack_require__.e(16).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["MessageType","VideoWorkerShared","avcCBoxToDescription","avcCBox","stream","StreamDataView","undefined","setNextUint8","configurationVersion","AVCProfileIndication","profile_compatibility","AVCLevelIndication","lengthSizeMinusOne","nb_SPS_nalus","i","SPS","length","setNextUint16","j","nalu","nb_PPS_nalus","PPS","ext","getBuffer","Processor","options","decoder","encoder","inFile","inInfo","outFile","expectedFrames","currentDecodingFrame","currentEncodingFrame","outTrackId","infoReady","modifyFrame","progressInit","progressUpdate","this","MP4Box","onReady","onInInfoReady","bind","onSamples","onInSamples","close","VideoEncoder","output","handleEncodedFrame","error","handleEncoderError","VideoDecoder","handleDecodedFrame","handleDecoderError","file","reset","reader","getReader","bytesRead","read","done","value","buffer","fileStart","appendBuffer","byteLength","Error","configure","codec","width","height","bitrate","videoTracks","framerate","nb_samples","setExtractionOptions","id","start","flush","info","codedWidth","track_width","codedHeight","track_height","description","moov","traks","mdia","minf","stbl","stsd","entries","avcC","trackId","user","samples","sample","chunk","EncodedVideoChunk","data","duration","Math","floor","timescale","timestamp","dts","type","is_sync","decode","frame","modifiedFrame","encode","keyFrame","createImageBitmap","then","previewBitmap","e","metadata","addTrack","avcDecoderConfigRecord","decoderConfig","ArrayBuffer","copyTo","addSample","cts","blob","Blob","url","URL","createObjectURL","postMessage","blobString","console","TILES_PER_PAGE","Font","name","tiles","index","arrayBuffer","isHd","includes","tileWidth","tileHeight","tileIndex","pixData","Uint8ClampedArray","imageData","ImageData","imageBitmap","push","files","fonts","map","fromFile","Promise","all","fontPack","sd1","find","font","sd2","hd1","hd2","OsdReader","header","frames","magic","getNextString","version","getNextUint16","config","charWidth","getNextUint8","charHeight","fontWidth","fontHeight","xOffset","yOffset","fontVariant","getOffset","frameNumber","getNextUint32","frameSize","frameData","Uint16Array","setOffset","VideoWorker","processor","osdReader","lastOsdIndex","wide","hd","outWidth","outHeight","osdCanvas","osdCtx","frameCanvas","frameCtx","addEventListener","onMessage","log","OffscreenCanvas","getContext","processSamples","frameIndex","frameXOffset","fillStyle","fillRect","clearRect","displayWidth","drawImage","nextOsdIndex","osdFrame","y","x","osdFrameIndex","osdFrameChar","getTile","osdScale","osdWidth","osdHeight","osdXOffset","osdYOffset","VideoFrame","currentFrame","preview","event","message","debug","osdFile","fromFiles","fontFiles","processFile","videoFile","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","call","m","__webpack_exports__","O","deferred","result","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","Object","keys","every","key","splice","r","n","getter","__esModule","d","a","definition","o","defineProperty","enumerable","get","f","chunkId","reduce","promises","u","miniCssF","obj","prop","prototype","hasOwnProperty","p","installedChunks","importScripts","chunkLoadingGlobal","self","parentChunkLoadingFunction","moreModules","runtime","pop","next"],"sourceRoot":""}