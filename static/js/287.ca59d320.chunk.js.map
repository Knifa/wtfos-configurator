{"version":3,"file":"static/js/287.ca59d320.chunk.js","mappings":"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","sources":["features/osd-overlay/video-worker/shared.ts","features/osd-overlay/video-worker/processor.ts","features/osd-overlay/video-worker/fonts.ts","features/osd-overlay/video-worker/osd.ts","features/osd-overlay/video-worker/worker.ts","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/compat get default export","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["namespace VideoWorkerShared {\n  export const enum MessageType {\n    FILE_IN,\n    FILE_OUT,\n    PROGRESS_INIT,\n    PROGRESS_UPDATE,\n  }\n\n  export interface FileInMessage {\n    type: MessageType.FILE_IN;\n    fontFiles: File[];\n    osdFile: File;\n    videoFile: File;\n  }\n\n  export interface FileOutMessage {\n    type: MessageType.FILE_OUT;\n    buffer: ArrayBuffer;\n  }\n\n  export interface ProgressInitMessage {\n    type: MessageType.PROGRESS_INIT;\n    expectedFrames: number;\n  }\n\n  export interface ProgressUpdateMessage {\n    type: MessageType.PROGRESS_UPDATE;\n    currentFrame?: number;\n    preview?: ImageBitmap;\n  }\n\n  export type Message =\n    | FileInMessage\n    | FileOutMessage\n    | ProgressInitMessage\n    | ProgressUpdateMessage;\n}\n\nexport default VideoWorkerShared;\n","import MP4Box from \"mp4box\";\nimport VideoWorkerShared from \"./shared\";\nimport { StreamDataView } from \"stream-data-view\";\n\nconst MAX_QUEUE_SIZE = 15;\nconst KEYFRAME_INTERVAL = 60;\n\nfunction avcCBoxToDescription(avcCBox: any): ArrayBuffer {\n  const stream = new StreamDataView(undefined, true);\n\n  stream.setNextUint8(avcCBox.configurationVersion);\n  stream.setNextUint8(avcCBox.AVCProfileIndication);\n  stream.setNextUint8(avcCBox.profile_compatibility);\n  stream.setNextUint8(avcCBox.AVCLevelIndication);\n  stream.setNextUint8(avcCBox.lengthSizeMinusOne + (63 << 2));\n\n  stream.setNextUint8(avcCBox.nb_SPS_nalus + (7 << 5));\n  for (let i = 0; i < avcCBox.SPS.length; i++) {\n    stream.setNextUint16(avcCBox.SPS[i].length);\n    for (let j = 0; j < avcCBox.SPS[i].length; j++) {\n      stream.setNextUint8(avcCBox.SPS[i].nalu[j]);\n    }\n  }\n\n  stream.setNextUint8(avcCBox.nb_PPS_nalus);\n  for (let i = 0; i < avcCBox.PPS.length; i++) {\n    stream.setNextUint16(avcCBox.PPS[i].length);\n    for (let j = 0; j < avcCBox.PPS[i].length; j++) {\n      stream.setNextUint8(avcCBox.PPS[i].nalu[j]);\n    }\n  }\n\n  if (avcCBox.ext) {\n    for (let i = 0; i < avcCBox.ext.length; i++) {\n      stream.setNextUint8(avcCBox.ext[i]);\n    }\n  }\n\n  return stream.getBuffer();\n}\n\ntype InfoReadyCallback = (info: MP4Box.ISOFileInfo) => void;\ntype ModifyFrameCallback = (frame: VideoFrame, index: number) => VideoFrame;\ntype ProgressInitCallback = (total: number) => void;\ntype ProgressCallback = (processed?: number, preview?: ImageBitmap) => void;\n\nexport interface ProcessorOptions {\n  infoReady: InfoReadyCallback;\n  modifyFrame: ModifyFrameCallback;\n  progressInit: ProgressInitCallback;\n  progressUpdate: ProgressCallback;\n}\n\nexport class Processor {\n  decoder?: VideoDecoder;\n  encoder?: VideoEncoder;\n\n  inFile?: MP4Box.ISOFile;\n  inInfo?: MP4Box.ISOFileInfo;\n  outFile?: MP4Box.ISOFile;\n\n  expectedFrames: number = 0;\n  currentDecodingFrame: number = 0;\n  currentEncodingFrame: number = 0;\n  outTrackId?: number;\n\n  infoReady: InfoReadyCallback;\n  modifyFrame: ModifyFrameCallback;\n  progressInit: ProgressInitCallback;\n  progressUpdate: ProgressCallback;\n\n  samples: MP4Box.VideoSample[] = [];\n\n  constructor(options: ProcessorOptions) {\n    this.infoReady = options.infoReady;\n    this.modifyFrame = options.modifyFrame;\n    this.progressInit = options.progressInit;\n    this.progressUpdate = options.progressUpdate;\n  }\n\n  reset() {\n    this.inFile = MP4Box.createFile();\n    this.inFile.onReady = this.onInInfoReady.bind(this);\n    this.inFile.onSamples = this.onInSamples.bind(this);\n    this.inFile.onError = this.onInError.bind(this);\n\n    this.outFile = MP4Box.createFile();\n\n    if (this.encoder) {\n      this.encoder.close();\n    }\n\n    this.encoder = new VideoEncoder({\n      output: this.handleEncodedFrame.bind(this),\n      error: this.handleEncoderError.bind(this),\n    });\n\n    if (this.decoder) {\n      this.decoder.close();\n    }\n\n    this.decoder = new VideoDecoder({\n      output: this.handleDecodedFrame.bind(this),\n      error: this.handleDecoderError.bind(this),\n    });\n\n    this.samples = [];\n  }\n\n  async processFile(file: File) {\n    this.reset();\n\n    const stream = file.stream();\n    const reader = stream.getReader();\n\n    let bytesRead = 0;\n    while (true) { // eslint-disable-line no-constant-condition\n      const {\n        done,\n        value,\n      } = await reader.read();\n\n      if (done) {\n        break;\n      }\n\n      const buffer = value.buffer;\n      (buffer as any).fileStart = bytesRead;\n      this.inFile!.appendBuffer(buffer);\n      bytesRead += value.byteLength;\n    }\n  }\n\n  processSamples(options: { width: number; height: number }) {\n    if (!this.inInfo) {\n      throw new Error(\"No info?\");\n    }\n\n    this.encoder!.configure({\n      codec: \"avc1.42003d\",\n      width: options.width,\n      height: options.height,\n      bitrate: this.inInfo.videoTracks[0].bitrate,\n      framerate: 60,\n    });\n\n    this.expectedFrames = this.inInfo.videoTracks[0].nb_samples;\n    this.currentDecodingFrame = 0;\n    this.currentEncodingFrame = 0;\n\n    this.progressInit(this.expectedFrames);\n\n    this.inFile!.setExtractionOptions(this.inInfo.videoTracks[0].id, undefined, {\n      nbSamples: 1,\n      rapAlignement: false,\n    });\n    this.inFile!.start();\n    this.inFile!.flush();\n  }\n\n  onInInfoReady(info: MP4Box.ISOFileInfo) {\n    this.inInfo = info;\n\n    this.decoder!.configure({\n      codec: info.videoTracks[0].codec,\n      codedWidth: info.videoTracks[0].track_width,\n      codedHeight: info.videoTracks[0].track_height,\n      description: avcCBoxToDescription(\n        (this.inFile as any).moov.traks[0].mdia.minf.stbl.stsd.entries[0].avcC\n      ),\n    });\n\n    this.infoReady(info);\n  }\n\n  onInSamples(trackId: unknown, user: unknown, samples: MP4Box.VideoSample[]) {\n    for (const sample of samples) {\n      this.samples.push(sample);\n    }\n\n    if (this.samples.length === this.expectedFrames) {\n      this.decodeNextSamples();\n    }\n  }\n\n  decodeNextSamples() {\n    if ((this.decoder!.decodeQueueSize > MAX_QUEUE_SIZE || this.encoder!.encodeQueueSize > MAX_QUEUE_SIZE) && !(this.samples.length <= MAX_QUEUE_SIZE)) {\n      // console.debug(\"Asked to queue but encoder/decoder is busy, aborting\");\n      return;\n    }\n\n    const sample = this.samples.shift();\n    if (!sample) {\n      console.error(\"No sample?\");\n      return;\n    }\n\n    const chunk = new EncodedVideoChunk({\n      data: sample.data,\n      duration: Math.floor((sample.duration / sample.timescale) * 1_000_000),\n      timestamp: Math.floor((sample.dts / sample.timescale) * 1_000_000),\n      type: sample.is_sync ? \"key\" : \"delta\",\n    });\n\n    this.decoder!.decode(chunk);\n\n    if (this.samples.length > 0 && !this.samples[0].is_sync) {\n      this.decodeNextSamples();\n    } else {\n      console.debug(`Flushing decoder at decoded frame ${this.currentDecodingFrame}`);\n      this.decoder!.flush();\n    }\n  }\n\n\n  handleDecodedFrame(frame: VideoFrame) {\n    const modifiedFrame = this.modifyFrame!(frame, this.currentDecodingFrame);\n    frame.close();\n\n    if (this.currentDecodingFrame % KEYFRAME_INTERVAL === 0) {\n      console.debug(`Flushing encoder at decoded frame ${this.currentDecodingFrame}, keyframe incoming.`);\n      this.encoder!.flush();\n    }\n\n    this.encoder!.encode(modifiedFrame, { keyFrame: this.currentDecodingFrame % KEYFRAME_INTERVAL === 0 });\n\n    if (this.currentDecodingFrame % KEYFRAME_INTERVAL === 0) {\n      createImageBitmap(modifiedFrame).then((previewBitmap) => {\n        this.progressUpdate(undefined, previewBitmap);\n      });\n    }\n\n    this.currentDecodingFrame++;\n    this.inFile!.releaseUsedSamples(this.inInfo!.videoTracks[0].id, this.currentDecodingFrame);\n\n    if (this.currentDecodingFrame === this.expectedFrames) {\n      console.debug(`Flushing encoder at decoded frame ${this.currentDecodingFrame}, last frame.`);\n      this.encoder!.flush();\n    }\n\n    modifiedFrame.close();\n  }\n\n  handleEncodedFrame(\n    chunk: EncodedVideoChunk,\n    metadata: EncodedVideoChunkMetadata\n  ) {\n    if (!this.outTrackId) {\n      this.outTrackId = this.outFile!.addTrack({\n        avcDecoderConfigRecord: metadata.decoderConfig?.description,\n        height: this.inInfo!.videoTracks[0].track_height,\n        nb_samples: this.inInfo!.videoTracks[0].nb_samples,\n        timescale: this.inInfo!.videoTracks[0].timescale,\n        width: this.inInfo!.videoTracks[0].track_width,\n      });\n    }\n\n    const buffer = new ArrayBuffer(chunk.byteLength);\n    chunk.copyTo(buffer);\n\n    this.outFile!.addSample(this.outTrackId, buffer, {\n      cts: this.currentEncodingFrame,\n      dts: this.currentEncodingFrame,\n      duration: 1,\n      is_sync: chunk.type === \"key\",\n    });\n\n    this.progressUpdate(this.currentEncodingFrame);\n\n    this.currentEncodingFrame++;\n\n    if (this.currentEncodingFrame === this.expectedFrames) {\n      const buffer = this.outFile!.getBuffer();\n\n      postMessage({\n        type: VideoWorkerShared.MessageType.FILE_OUT,\n        buffer,\n      } as VideoWorkerShared.FileOutMessage, [buffer]);\n    } else {\n      if (this.samples.length > 0) {\n        // console.debug(\"Encoder not done, queueing next samples for decoding\");\n        this.decodeNextSamples();\n      }\n    }\n  }\n\n  onInError(e: Error) {\n    throw e;\n  }\n\n  handleDecoderError(e: Error) {\n    throw e;\n  }\n\n  handleEncoderError(e: Error) {\n    throw e;\n  }\n}\n","export const SD_TILE_WIDTH = 12 * 3;\nexport const SD_TILE_HEIGHT = 18 * 3;\n\nexport const HD_TILE_WIDTH = 12 * 2;\nexport const HD_TILE_HEIGHT = 18 * 2;\n\nexport const TILES_PER_PAGE = 256;\n\nexport interface FontPack {\n  sd1: Font;\n  sd2: Font;\n  hd1: Font;\n  hd2: Font;\n}\n\nexport class Font {\n  readonly name: string;\n  readonly tiles: ImageBitmap[];\n\n  constructor(name: string, tiles: ImageBitmap[]) {\n    this.name = name;\n    this.tiles = tiles;\n  }\n\n  getTile(index: number): ImageBitmap {\n    return this.tiles[index];\n  }\n\n  static async fromFile(file: File): Promise<Font> {\n    const data = await file.arrayBuffer();\n    const isHd = file.name.includes(\"hd\");\n\n    const tileWidth = isHd ? HD_TILE_WIDTH : SD_TILE_WIDTH;\n    const tileHeight = isHd ? HD_TILE_HEIGHT : SD_TILE_HEIGHT;\n\n    const tiles: ImageBitmap[] = [];\n    for (let tileIndex = 0; tileIndex < TILES_PER_PAGE; tileIndex++) {\n      const pixData = new Uint8ClampedArray(\n        data,\n        tileIndex * tileWidth * tileHeight * 4,\n        tileWidth * tileHeight * 4\n      );\n\n      const imageData = new ImageData(pixData, tileWidth, tileHeight);\n      const imageBitmap = await createImageBitmap(imageData);\n      tiles.push(imageBitmap);\n    }\n\n    return new Font(file.name, tiles);\n  }\n\n  static async fromFiles(files: File[]): Promise<FontPack> {\n    const fonts = files.map((file) => Font.fromFile(file));\n    const fontPack = await Promise.all(fonts);\n\n    return {\n      sd1: fontPack.find(\n        (font) => !font.name.includes(\"_2\") && !font.name.includes(\"hd\")\n      )!,\n      sd2: fontPack.find(\n        (font) => font.name.includes(\"_2\") && !font.name.includes(\"hd\")\n      )!,\n      hd1: fontPack.find(\n        (font) => !font.name.includes(\"_2\") && font.name.includes(\"hd\")\n      )!,\n      hd2: fontPack.find(\n        (font) => font.name.includes(\"_2\") && font.name.includes(\"hd\")\n      )!,\n    };\n  }\n}\n","import { StreamDataView } from \"stream-data-view\";\n\ninterface OsdHeader {\n  magic: string;\n  version: number;\n  config: OsdConfig;\n}\n\ninterface OsdConfig {\n  charWidth: number;\n  charHeight: number;\n  fontWidth: number;\n  fontHeight: number;\n  xOffset: number;\n  yOffset: number;\n  fontVariant: number;\n}\n\ninterface OsdFrame {\n  frameNumber: number;\n  frameSize: number;\n  frameData: Uint16Array;\n}\n\nexport class OsdReader {\n  readonly header: OsdHeader;\n  readonly frames: OsdFrame[] = [];\n\n  constructor(data: ArrayBuffer) {\n    const stream = new StreamDataView(data);\n    this.header = {\n      magic: stream.getNextString(7),\n      version: stream.getNextUint16(),\n      config: {\n        charWidth: stream.getNextUint8(),\n        charHeight: stream.getNextUint8(),\n        fontWidth: stream.getNextUint8(),\n        fontHeight: stream.getNextUint8(),\n        xOffset: stream.getNextUint16(),\n        yOffset: stream.getNextUint16(),\n        fontVariant: stream.getNextUint8(),\n      },\n    };\n\n    if (this.header.config.charWidth === 31) {\n      this.header.config.charWidth = 30;\n    }\n\n    while (stream.getOffset() < data.byteLength) {\n      const frameNumber = stream.getNextUint32();\n      const frameSize = stream.getNextUint32();\n      const frameData = new Uint16Array(data, stream.getOffset(), frameSize);\n      stream.setOffset(stream.getOffset() + frameSize * 2);\n\n      this.frames.push({\n        frameNumber,\n        frameSize,\n        frameData,\n      });\n    }\n  }\n\n  static async fromFile(file: File): Promise<OsdReader> {\n    const data = await file.arrayBuffer();\n    return new OsdReader(data);\n  }\n}\n","/// <reference lib=\"webworker\" />\n\nimport VideoWorkerShared from \"./shared\";\nimport { Processor } from \"./processor\";\nimport {\n  Font,\n  FontPack,\n  TILES_PER_PAGE,\n} from \"./fonts\";\nimport { OsdReader } from \"./osd\";\nimport MP4Box from \"mp4box\";\n\nconst MAX_DISPLAY_X = 60;\nconst MAX_DISPLAY_Y = 22;\n\nexport class VideoWorker {\n  readonly processor: Processor;\n  fontPack?: FontPack;\n  osdReader?: OsdReader;\n\n  lastOsdIndex: number = 0;\n\n  wide: boolean = false;\n  hd: boolean = false;\n  outWidth?: number;\n  outHeight?: number;\n\n  osdCanvas?: OffscreenCanvas;\n  osdCtx?: OffscreenCanvasRenderingContext2D;\n  frameCanvas?: OffscreenCanvas;\n  frameCtx?: OffscreenCanvasRenderingContext2D;\n\n  constructor() {\n    this.processor = new Processor({\n      infoReady: this.infoReady.bind(this),\n      modifyFrame: this.modifyFrame.bind(this),\n      progressInit: this.progressInit.bind(this),\n      progressUpdate: this.progressUpdate.bind(this),\n    });\n\n    addEventListener(\"message\", this.onMessage.bind(this)); // eslint-disable-line no-restricted-globals\n  }\n\n  infoReady(info: MP4Box.ISOFileInfo) {\n    const width = info.videoTracks[0].track_width;\n    const height = info.videoTracks[0].track_height;\n\n    if (width === 1280 && height === 720) {\n      this.wide = true;\n    }\n\n    if (this.osdReader!.header.config.fontWidth === 24) {\n      this.hd = true;\n    }\n\n    let outWidth: number;\n    let outHeight: number;\n    if (this.wide || this.hd) {\n      outWidth = 1280;\n      outHeight = 720;\n    } else {\n      outWidth = width;\n      outHeight = height;\n    }\n\n    this.outWidth = outWidth;\n    this.outHeight = outHeight;\n\n    this.osdCanvas = new OffscreenCanvas(\n      this.osdReader!.header.config.fontWidth * this.osdReader!.header.config.charWidth,\n      this.osdReader!.header.config.fontHeight * this.osdReader!.header.config.charHeight\n    );\n    this.osdCtx = this.osdCanvas.getContext(\"2d\")!;\n\n    this.frameCanvas = new OffscreenCanvas(this.outWidth!, this.outHeight!);\n    this.frameCtx = this.frameCanvas.getContext(\"2d\")!;\n\n    this.processor.processSamples({\n      width: outWidth,\n      height: outHeight,\n    });\n  }\n\n  modifyFrame(frame: VideoFrame, frameIndex: number): VideoFrame {\n    const osdCanvas = this.osdCanvas!;\n    const osdCtx = this.osdCtx!;\n    const frameCanvas = this.frameCanvas!;\n    const frameCtx = this.frameCtx!;\n\n    frameCtx.fillStyle = \"black\";\n    frameCtx.fillRect(0, 0, frameCanvas.width, frameCanvas.height);\n    osdCtx.clearRect(0, 0, osdCanvas.width, osdCanvas.height);\n\n    let frameXOffset: number;\n    if (this.hd || this.wide) {\n      frameXOffset = (this.outWidth! - frame.displayWidth) / 2;\n    } else {\n      frameXOffset = 0;\n    }\n    frameCtx.drawImage(frame, frameXOffset, 0);\n\n    if (this.lastOsdIndex < this.osdReader!.frames.length - 1) {\n      const nextOsdIndex = this.lastOsdIndex + 1;\n      const nextOsdFrame = this.osdReader!.frames[nextOsdIndex];\n\n      if (frameIndex >= nextOsdFrame.frameNumber) {\n        this.lastOsdIndex = nextOsdIndex;\n      }\n    }\n\n    const osdFrame = this.osdReader!.frames[this.lastOsdIndex];\n    for (let y = 0; y < MAX_DISPLAY_Y; y++) {\n      for (let x = 0; x < MAX_DISPLAY_X; x++) {\n        const osdFrameIndex = y + MAX_DISPLAY_Y * x;\n        const osdFrameChar = osdFrame.frameData[osdFrameIndex];\n\n        let font: Font;\n        if (this.hd) {\n          font =\n            osdFrameChar < TILES_PER_PAGE\n              ? this.fontPack!.hd1\n              : this.fontPack!.hd2;\n        } else {\n          font =\n            osdFrameChar < TILES_PER_PAGE\n              ? this.fontPack!.sd1\n              : this.fontPack!.sd2;\n        }\n\n        osdCtx.drawImage(\n          font.getTile(osdFrameChar % TILES_PER_PAGE),\n          x * this.osdReader!.header.config.fontWidth,\n          y * this.osdReader!.header.config.fontHeight\n        );\n      }\n    }\n\n    const osdScale = frameCanvas.height / osdCanvas.height;\n    const osdWidth = osdCanvas.width * osdScale;\n    const osdHeight = osdCanvas.height * osdScale;\n    const osdXOffset = (frameCanvas.width - osdWidth) / 2;\n    const osdYOffset = (frameCanvas.height - osdHeight) / 2;\n\n    frameCtx.drawImage(\n      osdCanvas,\n      osdXOffset,\n      osdYOffset,\n      osdWidth,\n      osdHeight\n    );\n\n    return new VideoFrame(frameCanvas as any, { timestamp: frame.timestamp! });\n  }\n\n  progressInit(expectedFrames: number) {\n    postMessage({\n      type: VideoWorkerShared.MessageType.PROGRESS_INIT,\n      expectedFrames,\n    });\n  }\n\n  progressUpdate(currentFrame?: number, preview?: ImageBitmap) {\n    postMessage({\n      type: VideoWorkerShared.MessageType.PROGRESS_UPDATE,\n      currentFrame,\n      preview,\n    }, [...(preview ? [preview] : [])]);\n  }\n\n  async onMessage(event: MessageEvent<VideoWorkerShared.Message>) {\n    const message = event.data;\n    switch (message.type) {\n      case VideoWorkerShared.MessageType.FILE_IN: {\n        console.debug(\"Hello from the worker!\");\n\n        this.osdReader = await OsdReader.fromFile(message.osdFile);\n        console.debug(\"Got OSD reader\");\n\n        this.fontPack = await Font.fromFiles(message.fontFiles);\n        console.debug(\"Got font pack\");\n\n        console.debug(\"Starting processor...\");\n        this.processor.processFile(message.videoFile);\n        break;\n      }\n\n      default: {\n        throw new Error(\"Unknown message type received\");\n      }\n    }\n  }\n}\n\nnew VideoWorker();\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [16], function() { return __webpack_require__(9287); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n\tvar getter = module && module.__esModule ?\n\t\tfunction() { return module['default']; } :\n\t\tfunction() { return module; };\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"57fd4f51\" + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","__webpack_require__.p = \"/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t287: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkwtfos_configurator\"] = self[\"webpackChunkwtfos_configurator\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn __webpack_require__.e(16).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["MessageType","VideoWorkerShared","avcCBoxToDescription","avcCBox","stream","StreamDataView","undefined","setNextUint8","configurationVersion","AVCProfileIndication","profile_compatibility","AVCLevelIndication","lengthSizeMinusOne","nb_SPS_nalus","i","SPS","length","setNextUint16","j","nalu","nb_PPS_nalus","PPS","ext","getBuffer","Processor","options","decoder","encoder","inFile","inInfo","outFile","expectedFrames","currentDecodingFrame","currentEncodingFrame","outTrackId","infoReady","modifyFrame","progressInit","progressUpdate","samples","this","MP4Box","onReady","onInInfoReady","bind","onSamples","onInSamples","onError","onInError","close","VideoEncoder","output","handleEncodedFrame","error","handleEncoderError","VideoDecoder","handleDecodedFrame","handleDecoderError","file","reset","reader","getReader","bytesRead","read","done","value","buffer","fileStart","appendBuffer","byteLength","Error","configure","codec","width","height","bitrate","videoTracks","framerate","nb_samples","setExtractionOptions","id","nbSamples","rapAlignement","start","flush","info","codedWidth","track_width","codedHeight","track_height","description","moov","traks","mdia","minf","stbl","stsd","entries","avcC","trackId","user","sample","push","decodeNextSamples","decodeQueueSize","encodeQueueSize","shift","chunk","EncodedVideoChunk","data","duration","Math","floor","timescale","timestamp","dts","type","is_sync","decode","console","debug","frame","modifiedFrame","encode","keyFrame","createImageBitmap","then","previewBitmap","releaseUsedSamples","metadata","addTrack","avcDecoderConfigRecord","decoderConfig","ArrayBuffer","copyTo","addSample","cts","postMessage","e","TILES_PER_PAGE","Font","name","tiles","index","arrayBuffer","isHd","includes","tileWidth","tileHeight","tileIndex","pixData","Uint8ClampedArray","imageData","ImageData","imageBitmap","files","fonts","map","fromFile","Promise","all","fontPack","sd1","find","font","sd2","hd1","hd2","OsdReader","header","frames","magic","getNextString","version","getNextUint16","config","charWidth","getNextUint8","charHeight","fontWidth","fontHeight","xOffset","yOffset","fontVariant","getOffset","frameNumber","getNextUint32","frameSize","frameData","Uint16Array","setOffset","VideoWorker","processor","osdReader","lastOsdIndex","wide","hd","outWidth","outHeight","osdCanvas","osdCtx","frameCanvas","frameCtx","addEventListener","onMessage","OffscreenCanvas","getContext","processSamples","frameIndex","frameXOffset","fillStyle","fillRect","clearRect","displayWidth","drawImage","nextOsdIndex","osdFrame","y","x","osdFrameIndex","osdFrameChar","getTile","osdScale","osdWidth","osdHeight","osdXOffset","osdYOffset","VideoFrame","currentFrame","preview","event","message","osdFile","fromFiles","fontFiles","processFile","videoFile","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","call","m","__webpack_exports__","O","deferred","result","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","Object","keys","every","key","splice","r","n","getter","__esModule","d","a","definition","o","defineProperty","enumerable","get","f","chunkId","reduce","promises","u","miniCssF","obj","prop","prototype","hasOwnProperty","p","installedChunks","importScripts","chunkLoadingGlobal","self","parentChunkLoadingFunction","moreModules","runtime","pop","next"],"sourceRoot":""}