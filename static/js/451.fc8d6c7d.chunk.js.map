{"version":3,"file":"static/js/451.fc8d6c7d.chunk.js","mappings":"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","sources":["features/osd-overlay/video-worker/shared.ts","features/osd-overlay/video-worker/mp4/io/reader.ts","features/osd-overlay/video-worker/mp4/io/writer.ts","features/osd-overlay/video-worker/mp4/parsers.ts","features/osd-overlay/video-worker/mp4/writers.ts","features/osd-overlay/video-worker/mp4/index.ts","features/osd-overlay/video-worker/processor.ts","features/osd-overlay/video-worker/fonts.ts","features/osd-overlay/video-worker/osd.ts","features/osd-overlay/video-worker/worker.ts","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/compat get default export","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["namespace VideoWorkerShared {\n  export const enum MessageType {\n    FILE_IN,\n    FILE_OUT,\n    PROGRESS_INIT,\n    PROGRESS_UPDATE,\n  }\n\n  export interface FileInMessage {\n    type: MessageType.FILE_IN;\n    fontFiles: File[];\n    osdFile: File;\n    videoFile: File;\n    outHandle: FileSystemFileHandle;\n  }\n\n  export interface FileOutMessage {\n    type: MessageType.FILE_OUT;\n  }\n\n  export interface ProgressInitMessage {\n    type: MessageType.PROGRESS_INIT;\n    expectedFrames: number;\n  }\n\n  export interface ProgressUpdateMessage {\n    type: MessageType.PROGRESS_UPDATE;\n    currentFrame?: number;\n    preview?: ImageBitmap;\n  }\n\n  export type Message =\n    | FileInMessage\n    | FileOutMessage\n    | ProgressInitMessage\n    | ProgressUpdateMessage;\n}\n\nexport default VideoWorkerShared;\n","export class FileStreamReader {\n  private static readonly BUFFER_SIZE = 1024 * 1024 * 8; // 8MB\n\n  private file: File;\n\n  private buffer = new ArrayBuffer(0);\n  private bufferOffset = 0;\n  private _offset = 0;\n\n  constructor(file: File) {\n    this.file = file;\n  }\n\n  async getNextString(length?: number): Promise<string> {\n    let bytes: Uint8Array;\n\n    if (length) {\n      bytes = await this.getNextBytes(length);\n    } else {\n      const byteBuffer = [];\n      let byte: number;\n      while ((byte = await this.getNextUint8()) !== 0) {\n        byteBuffer.push(byte);\n      }\n\n      bytes = new Uint8Array(byteBuffer);\n    }\n\n    const decoder = new TextDecoder();\n    const string = decoder.decode(bytes);\n    return string;\n  }\n\n  async getNextUint8(): Promise<number> {\n    const view = await this.getDataView(1);\n    return view.getUint8(0);\n  }\n\n  async getNextUint16(): Promise<number> {\n    const view = await this.getDataView(2);\n    return view.getUint16(0);\n  }\n\n  async getNextUint32(): Promise<number> {\n    const view = await this.getDataView(4);\n    return view.getUint32(0);\n  }\n\n  async getNextUint64(): Promise<bigint> {\n    const view = await this.getDataView(8);\n    return view.getBigUint64(0);\n  }\n\n  async getNextBytes(length: number): Promise<Uint8Array> {\n    const view = await this.getDataView(length);\n    const result = new Uint8Array(length);\n    for (let i = 0; i < length; i++) {\n      result[i] = view.getUint8(i);\n    }\n\n    return result;\n  }\n\n  seek(offset: number) {\n    this._offset = offset;\n    if (\n      this._offset < this.bufferOffset ||\n      this._offset > this.bufferEndOffset\n    ) {\n      this.buffer = new ArrayBuffer(0);\n      this.bufferOffset = this._offset;\n    }\n  }\n\n  skip(length: number) {\n    this._offset += length;\n  }\n\n  get eof() {\n    return this.offset >= this.file.size;\n  }\n\n  get offset() {\n    return this._offset;\n  }\n\n  get size() {\n    return this.file.size;\n  }\n\n  private async fillBuffer(length: number) {\n    const fillEndOffset = this.offset + length;\n\n    if (fillEndOffset > this.bufferEndOffset) {\n      const newBufferOffset =\n        Math.floor(this.offset / FileStreamReader.BUFFER_SIZE) *\n        FileStreamReader.BUFFER_SIZE;\n      const newBufferEndOffset =\n        Math.ceil(fillEndOffset / FileStreamReader.BUFFER_SIZE) *\n        FileStreamReader.BUFFER_SIZE;\n\n      this.buffer = await this.file\n        .slice(newBufferOffset, newBufferEndOffset)\n        .arrayBuffer();\n      this.bufferOffset = newBufferOffset;\n    }\n  }\n\n  private async getDataView(length: number): Promise<DataView> {\n    await this.fillBuffer(length);\n\n    const result = new DataView(\n      this.buffer,\n      this.offset - this.bufferOffset,\n      length\n    );\n    this._offset += length;\n    return result;\n  }\n\n  private get bufferEndOffset() {\n    return this.bufferOffset + this.buffer.byteLength;\n  }\n}\n","/*\n  TODO:\n  - Keep a consistent buffer going instead of creating a new one every time.\n*/\n\nexport class FileStreamWriter {\n  private readonly file: FileSystemFileHandle;\n  private stream?: FileSystemWritableFileStream;\n\n  private _offset = 0;\n  private _size = 0;\n\n  constructor(file: FileSystemFileHandle) {\n    this.file = file;\n  }\n\n  async writeNextUint8(value: number): Promise<void> {\n    const array = new Uint8Array(1);\n    array[0] = value;\n\n    await this.writeNextBytes(array);\n  }\n\n  async writeNextUint16(value: number): Promise<void> {\n    const buffer = new ArrayBuffer(2);\n    const view = new DataView(buffer);\n    view.setUint16(0, value, false);\n\n    await this.writeNextBytes(buffer);\n  }\n\n  async writeNextUint32(value: number): Promise<void> {\n    const buffer = new ArrayBuffer(4);\n    const view = new DataView(buffer);\n    view.setUint32(0, value, false);\n\n    await this.writeNextBytes(buffer);\n  }\n\n  async writeNextUint64(value: number | bigint): Promise<void> {\n    if (typeof value === \"number\") {\n      value = BigInt(value);\n    }\n\n    const buffer = new ArrayBuffer(8);\n    const view = new DataView(buffer);\n    view.setBigUint64(0, value, false);\n\n    await this.writeNextBytes(buffer);\n  }\n\n  async writeNextString(value: string, length?: number): Promise<void> {\n    const buffer = new Uint8Array(\n      length !== undefined ? length : value.length + 1\n    );\n\n    const encoder = new TextEncoder();\n    encoder.encodeInto(value, buffer);\n\n    await this.writeNextBytes(buffer);\n  }\n\n  async writeNextBytes(bytes: BufferSource | Blob): Promise<void> {\n    const stream = await this.getStream();\n    await stream.write(bytes);\n\n    const byteLength = bytes instanceof Blob ? bytes.size : bytes.byteLength;\n    this._offset += byteLength;\n    this._size += byteLength;\n  }\n\n  async skip(length: number) {\n    await this.seek(this.offset + length);\n  }\n\n  async seek(offset: number) {\n    const stream = await this.getStream();\n    await stream.seek(offset);\n    this._offset = offset;\n  }\n\n  async close() {\n    const stream = await this.getStream();\n    await stream.close();\n    this.stream = undefined;\n  }\n\n  private async getStream(): Promise<FileSystemWritableFileStream> {\n    if (!this.stream) {\n      this.stream = await this.file.createWritable();\n      await this.stream.truncate(0);\n\n      this._size = 0;\n      this._offset = 0;\n    }\n\n    return this.stream;\n  }\n\n  get offset(): number {\n    return this._offset;\n  }\n\n  get size(): number {\n    return this._size;\n  }\n}\n","import { FileStreamReader } from \"./io/reader\";\nimport {\n  Avc1Box,\n  AvcCBox,\n  BaseBox,\n  BaseFullBox,\n  Box,\n  BoxHeader,\n  BoxType,\n  Co64Box,\n  DinfBox,\n  DrefBox,\n  FtypBox,\n  FullBoxHeader,\n  HdlrBox,\n  MdatBox,\n  MdhdBox,\n  MdiaBox,\n  MinfBox,\n  MoovBox,\n  MvhdBox,\n  SampleEntryBox,\n  StblBox,\n  StcoBox,\n  StscBox,\n  StsdBox,\n  StssBox,\n  StszBox,\n  SttsBox,\n  TkhdBox,\n  TrakBox,\n  UdtaBox,\n  UnknownBox,\n  UrlBox,\n  UrnBox,\n  VmhdBox,\n} from \"./types\";\n\nexport async function parseBox(stream: FileStreamReader): Promise<Box> {\n  const startOffset = stream.offset;\n\n  let size = await stream.getNextUint32();\n  const type = await stream.getNextString(4);\n\n  if (size === 0) {\n    size = stream.size - startOffset;\n    console.debug(\n      `${type} box has size 0, must continue until end of file: ${size}`\n    );\n  } else if (size === 1) {\n    // Not actually 64-bits but 9007TB is enough for any one box, I'm sure.\n    size = Number(await stream.getNextUint64());\n    console.debug(`${type} box has big size: ${size}`);\n  }\n\n  const boxParsers: Record<\n    string,\n    new (\n      stream: FileStreamReader,\n      startOffset: number,\n      size: number,\n      type: string\n    ) => BoxParser<Box>\n  > = {\n    \"url \": UrlBoxParser,\n    \"urn \": UrnBoxParser,\n    avc1: Avc1BoxParser,\n    avcC: AvcCBoxParser,\n    co64: Co64BoxParser,\n    dinf: DinfBoxParser,\n    dref: DrefBoxParser,\n    ftyp: FtypBoxParser,\n    hdlr: HdrlBoxParser,\n    mdat: MdatBoxParser,\n    mdhd: MdhdBoxParser,\n    mdia: MdiaBoxParser,\n    minf: MinfBoxParser,\n    moov: MoovBoxParser,\n    mvhd: MvhdBoxParser,\n    stbl: StblBoxParser,\n    stco: StcoBoxParser,\n    stsc: StscBoxParser,\n    stsd: StsdBoxParser,\n    stss: StssBoxParser,\n    stsz: StszBoxParser,\n    stts: SttsBoxParser,\n    tkhd: TkhdBoxParser,\n    trak: TrakBoxParser,\n    udta: UdtaBoxParser,\n    vmhd: VmhdBoxParser,\n  };\n\n  let parser: BoxParser<Box>;\n  if (boxParsers[type]) {\n    parser = new boxParsers[type](stream, startOffset, size, type);\n  } else {\n    console.warn(\n      `No parser available for %c${type}`,\n      \"text-decoration: underline\"\n    );\n    parser = new UnknownBoxParser(stream, startOffset, size, type);\n  }\n\n  return await parser.parse();\n}\n\nabstract class BoxParser<T extends BaseBox> {\n  protected readonly stream: FileStreamReader;\n  protected readonly size: number;\n  protected readonly type: string;\n  protected readonly startOffset: number;\n\n  protected readonly header: BoxHeader;\n\n  constructor(\n    stream: FileStreamReader,\n    startOffset: number,\n    size: number,\n    type: string\n  ) {\n    this.stream = stream;\n    this.startOffset = startOffset;\n    this.size = size;\n    this.type = type;\n\n    this.header = this.getHeader();\n  }\n\n  private getHeader(): BoxHeader {\n    const endOffset = this.startOffset + this.size;\n\n    return {\n      size: this.size,\n      type: this.type,\n\n      startOffset: this.startOffset,\n      endOffset,\n    };\n  }\n\n  protected async getChildBoxes(): Promise<Partial<Record<BoxType, Box[]>>> {\n    const boxes: Partial<Record<BoxType, Box[]>> = {};\n\n    while (this.stream.offset < this.header.endOffset) {\n      const box = await this.getNextChildBox();\n\n      if (box.type === \"unknown\") {\n        console.warn(\n          `Child box %c${box.header!.type}%c in %c${\n            this.type\n          }%c is unknown, ignoring.`,\n          \"text-decoration: underline\",\n          \"text-decoration: none\",\n          \"text-decoration: underline\",\n          \"text-decoration: none\"\n        );\n      }\n\n      if (!(box.type in boxes)) {\n        boxes[box.type] = [];\n      }\n\n      boxes[box.type]!.push(box);\n    }\n\n    return boxes;\n  }\n\n  protected async getNextChildBox(): Promise<Box> {\n    return await parseBox(this.stream);\n  }\n\n  protected seekToEnd(): void {\n    if (this.stream.offset !== this.header.endOffset) {\n      const diff = this.header.endOffset - this.stream.offset;\n      console.warn(\n        `Box %c${this.header.type}%c was not fully parsed! Stopped ${diff}B early.`,\n        \"text-decoration: underline\",\n        \"text-decoration: none\",\n        this.header\n      );\n    }\n\n    this.stream.seek(this.header.endOffset);\n  }\n\n  abstract parse(): Promise<T>;\n}\n\nabstract class SimpleBoxParser<T extends BaseBox> extends BoxParser<T> {\n  async parse(): Promise<T> {\n    const box = await this.parseBox(this.header);\n    this.seekToEnd();\n    return box;\n  }\n\n  protected abstract parseBox(header: BoxHeader): Promise<T>;\n}\n\nabstract class FullBoxParser<T extends BaseFullBox> extends BoxParser<T> {\n  protected async getFullBoxHeader() {\n    const version = await this.stream.getNextUint8();\n    const flags =\n      ((await this.stream.getNextUint8()) << 16) |\n      ((await this.stream.getNextUint8()) << 8) |\n      (await this.stream.getNextUint8());\n\n    return {\n      version,\n      flags,\n    };\n  }\n\n  async parse(): Promise<T> {\n    const fullBoxHeader = await this.getFullBoxHeader();\n    const box = await this.parseBox(this.header, fullBoxHeader);\n    this.seekToEnd();\n    return box;\n  }\n\n  protected abstract parseBox(\n    header: BoxHeader,\n    fullHeader: FullBoxHeader\n  ): Promise<T>;\n}\n\nclass FtypBoxParser extends SimpleBoxParser<FtypBox> {\n  async parseBox(header: BoxHeader): Promise<FtypBox> {\n    const majorBrand = await this.stream.getNextString(4);\n    const minorVersion = await this.stream.getNextUint32();\n    const compatibleBrands = [];\n\n    while (this.stream.offset < header.endOffset) {\n      compatibleBrands.push(await this.stream.getNextString(4));\n    }\n\n    return {\n      type: \"ftyp\",\n      header,\n      majorBrand,\n      minorVersion,\n      compatibleBrands,\n    };\n  }\n}\n\nclass MdatBoxParser extends SimpleBoxParser<MdatBox> {\n  async parseBox(header: BoxHeader): Promise<MdatBox> {\n    this.stream.seek(this.header.endOffset);\n\n    return {\n      type: \"mdat\",\n      header,\n    };\n  }\n}\n\nclass MoovBoxParser extends SimpleBoxParser<MoovBox> {\n  async parseBox(header: BoxHeader): Promise<MoovBox> {\n    const childBoxes = await this.getChildBoxes();\n\n    return {\n      type: \"moov\",\n      header,\n      mvhd: childBoxes.mvhd![0] as MvhdBox,\n      trak: childBoxes.trak as TrakBox[],\n    };\n  }\n}\n\nclass MvhdBoxParser extends FullBoxParser<MvhdBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<MvhdBox> {\n    if (fullBoxHeader.version === 1) {\n      throw new Error(\"Version 1 not supported\");\n    }\n\n    const creationTime = await this.stream.getNextUint32();\n    const modificationTime = await this.stream.getNextUint32();\n    const timescale = await this.stream.getNextUint32();\n    const duration = await this.stream.getNextUint32();\n    const rate = await this.stream.getNextUint32();\n    const volume = await this.stream.getNextUint16();\n\n    // Reserved.\n    await this.stream.getNextUint16();\n    await this.stream.getNextUint32();\n    await this.stream.getNextUint32();\n\n    const matrix = [];\n    for (let i = 0; i < 9; i++) {\n      matrix.push(await this.stream.getNextUint32());\n    }\n\n    // Predefined.\n    for (let i = 0; i < 6; i++) {\n      await this.stream.getNextUint32();\n    }\n\n    const nextTrackId = await this.stream.getNextUint32();\n\n    return {\n      header,\n      type: \"mvhd\",\n      fullBoxHeader,\n      creationTime,\n      modificationTime,\n      timescale,\n      duration,\n      rate,\n      volume,\n      matrix,\n      nextTrackId,\n    };\n  }\n}\n\nclass TrakBoxParser extends SimpleBoxParser<TrakBox> {\n  async parseBox(header: BoxHeader): Promise<TrakBox> {\n    const childBoxes = await this.getChildBoxes();\n\n    return {\n      header,\n      type: \"trak\",\n      tkhd: childBoxes.tkhd![0] as TkhdBox,\n      mdia: childBoxes.mdia![0] as MdiaBox,\n    };\n  }\n}\n\nclass TkhdBoxParser extends FullBoxParser<TkhdBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<TkhdBox> {\n    if (fullBoxHeader.version === 1) {\n      throw new Error(\"Version 1 not supported\");\n    }\n\n    const creationTime = await this.stream.getNextUint32();\n    const modificationTime = await this.stream.getNextUint32();\n    const trackId = await this.stream.getNextUint32();\n    await this.stream.getNextUint32(); // Reserved\n    const duration = await this.stream.getNextUint32();\n\n    await this.stream.getNextUint32(); // Reserved\n    await this.stream.getNextUint32(); // Reserved\n\n    const layer = await this.stream.getNextUint16();\n    const alternateGroup = await this.stream.getNextUint16();\n    const volume = await this.stream.getNextUint16();\n\n    await this.stream.getNextUint16(); // Reserved.\n\n    const matrix = [];\n    for (let i = 0; i < 9; i++) {\n      matrix.push(await this.stream.getNextUint32());\n    }\n\n    let width = (await this.stream.getNextUint32()) >> 16;\n    let height = (await this.stream.getNextUint32()) >> 16;\n\n    return {\n      header,\n      type: \"tkhd\",\n      fullBoxHeader,\n      creationTime,\n      modificationTime,\n      trackId,\n      duration,\n      layer,\n      alternateGroup,\n      volume,\n      matrix,\n      width,\n      height,\n    };\n  }\n}\n\nclass MdiaBoxParser extends SimpleBoxParser<MdiaBox> {\n  async parseBox(header: BoxHeader): Promise<MdiaBox> {\n    const childBoxes = await this.getChildBoxes();\n\n    return {\n      header,\n      type: \"mdia\",\n      mdhd: childBoxes.mdhd![0] as MdhdBox,\n      minf: childBoxes.minf![0] as MinfBox,\n      hdlr: childBoxes.hdlr![0] as HdlrBox,\n    };\n  }\n}\n\nclass MdhdBoxParser extends FullBoxParser<MdhdBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<MdhdBox> {\n    if (fullBoxHeader.version === 1) {\n      throw new Error(\"Version 1 not supported\");\n    }\n\n    let creationTime = await this.stream.getNextUint32();\n    let modificationTime = await this.stream.getNextUint32();\n    let timescale = await this.stream.getNextUint32();\n    let duration = await this.stream.getNextUint32();\n\n    // TODO: Parse this.\n    let language = \"\";\n    await this.stream.getNextUint16();\n\n    await this.stream.getNextUint16(); // Reserved.\n\n    return {\n      header,\n      type: \"mdhd\",\n      fullBoxHeader,\n      creationTime,\n      modificationTime,\n      timescale,\n      duration,\n      language,\n    };\n  }\n}\n\nclass MinfBoxParser extends SimpleBoxParser<MinfBox> {\n  async parseBox(header: BoxHeader): Promise<MinfBox> {\n    const childBoxes = await this.getChildBoxes();\n\n    return {\n      header,\n      type: \"minf\",\n      vmhd: \"vmhd\" in childBoxes ? (childBoxes.vmhd![0] as VmhdBox) : undefined,\n      stbl: childBoxes.stbl![0] as StblBox,\n      dinf: childBoxes.dinf![0] as DinfBox,\n    };\n  }\n}\n\nclass StblBoxParser extends SimpleBoxParser<StblBox> {\n  async parseBox(header: BoxHeader): Promise<StblBox> {\n    const childBoxes = await this.getChildBoxes();\n\n    return {\n      header,\n      type: \"stbl\",\n      stco: childBoxes.stco?.[0] as StcoBox,\n      co64: childBoxes.co64?.[0] as Co64Box,\n      stsc: childBoxes.stsc![0] as StscBox,\n      stsd: childBoxes.stsd![0] as StsdBox,\n      stss: childBoxes.stss![0] as StssBox,\n      stsz: childBoxes.stsz![0] as StszBox,\n      stts: childBoxes.stts![0] as SttsBox,\n    };\n  }\n}\n\nclass StsdBoxParser extends FullBoxParser<StsdBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<StsdBox> {\n    const entryCount = await this.stream.getNextUint32();\n\n    const entries = [];\n    for (let i = 0; i < entryCount; i++) {\n      const nextChild = (await this.getNextChildBox()) as SampleEntryBox;\n      entries.push(nextChild);\n    }\n\n    return {\n      header,\n      type: \"stsd\",\n      fullBoxHeader,\n      entries,\n    };\n  }\n}\n\nclass Avc1BoxParser extends SimpleBoxParser<Avc1Box> {\n  async parseBox(header: BoxHeader): Promise<Avc1Box> {\n    // Reserved\n    for (let i = 0; i < 6; i++) {\n      await this.stream.getNextUint8();\n    }\n\n    const dataReferenceIndex = await this.stream.getNextUint16();\n\n    // Technically from VisualSampleEntry but...\n    for (let i = 0; i < 2; i++) {\n      await this.stream.getNextUint16(); // Reserved\n    }\n    for (let i = 0; i < 3; i++) {\n      await this.stream.getNextUint32(); // Reserved\n    }\n\n    const width = await this.stream.getNextUint16();\n    const height = await this.stream.getNextUint16();\n    const horizontalResolution = await this.stream.getNextUint32();\n    const verticalResolution = await this.stream.getNextUint32();\n\n    await this.stream.getNextUint32(); // Reserved\n\n    const frameCount = await this.stream.getNextUint16();\n    const compressorName = await this.stream.getNextString(32);\n    const depth = await this.stream.getNextUint16();\n\n    await this.stream.getNextUint16(); // Reserved\n\n    const avcC = (await this.getNextChildBox()) as AvcCBox;\n\n    return {\n      header,\n      type: \"avc1\",\n      avcC,\n      compressorName,\n      dataReferenceIndex,\n      depth,\n      frameCount,\n      height,\n      horizontalResolution,\n      verticalResolution,\n      width,\n    };\n  }\n}\n\nclass AvcCBoxParser extends SimpleBoxParser<AvcCBox> {\n  async parseBox(header: BoxHeader): Promise<AvcCBox> {\n    const configurationVersion = await this.stream.getNextUint8();\n    const profileIndication = await this.stream.getNextUint8();\n    const profileCompatibility = await this.stream.getNextUint8();\n    const levelIndication = await this.stream.getNextUint8();\n    const lengthSizeMinusOne = (await this.stream.getNextUint8()) & 0x3;\n\n    const spsCount = (await this.stream.getNextUint8()) & 0x1f;\n    const sps = [];\n    for (let i = 0; i < spsCount; i++) {\n      const spsLength = await this.stream.getNextUint16();\n      const spsData = await this.stream.getNextBytes(spsLength);\n      sps.push(spsData);\n    }\n\n    const ppsCount = await this.stream.getNextUint8();\n    const pps = [];\n    for (let i = 0; i < ppsCount; i++) {\n      const ppsLength = await this.stream.getNextUint16();\n      const ppsData = await this.stream.getNextBytes(ppsLength);\n      pps.push(ppsData);\n    }\n\n    return {\n      header,\n      type: \"avcC\",\n      configurationVersion,\n      profileIndication,\n      profileCompatibility,\n      levelIndication,\n      lengthSizeMinusOne,\n      sequenceParameterSets: sps,\n      pictureParameterSets: pps,\n    };\n  }\n}\n\nclass StssBoxParser extends FullBoxParser<StssBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<StssBox> {\n    const entryCount = await this.stream.getNextUint32();\n    const sampleNumbers = [];\n    for (let i = 0; i < entryCount; i++) {\n      sampleNumbers.push(await this.stream.getNextUint32());\n    }\n\n    return {\n      header,\n      type: \"stss\",\n      fullBoxHeader,\n      sampleNumbers,\n    };\n  }\n}\n\nclass StcoBoxParser extends FullBoxParser<StcoBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<StcoBox> {\n    const entryCount = await this.stream.getNextUint32();\n    const chunkOffsets = [];\n    for (let i = 0; i < entryCount; i++) {\n      chunkOffsets.push(await this.stream.getNextUint32());\n    }\n\n    return {\n      header,\n      type: \"stco\",\n      fullBoxHeader,\n      chunkOffsets,\n    };\n  }\n}\n\nclass Co64BoxParser extends FullBoxParser<Co64Box> {\n  // TODO: Merge with StcoBoxParser?\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<Co64Box> {\n    const entryCount = await this.stream.getNextUint32();\n    const chunkOffsets = [];\n    for (let i = 0; i < entryCount; i++) {\n      chunkOffsets.push(Number(await this.stream.getNextUint64()));\n    }\n\n    return {\n      header,\n      type: \"co64\",\n      fullBoxHeader,\n      chunkOffsets,\n    };\n  }\n}\n\nclass StscBoxParser extends FullBoxParser<StscBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<StscBox> {\n    const entryCount = await this.stream.getNextUint32();\n    const entries = [];\n    for (let i = 0; i < entryCount; i++) {\n      entries.push({\n        firstChunk: await this.stream.getNextUint32(),\n        samplesPerChunk: await this.stream.getNextUint32(),\n        sampleDescriptionIndex: await this.stream.getNextUint32(),\n      });\n    }\n\n    return {\n      header,\n      type: \"stsc\",\n      fullBoxHeader,\n      entries,\n    };\n  }\n}\n\nclass StszBoxParser extends FullBoxParser<StszBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<StszBox> {\n    let sampleSizes = [await this.stream.getNextUint32()];\n    const sampleCount = await this.stream.getNextUint32();\n\n    // If sample size is 0, then we have a table of sample sizes, otherwise\n    // all samples are the same size.\n    if (sampleSizes[0] === 0) {\n      sampleSizes = [];\n      for (let i = 0; i < sampleCount; i++) {\n        sampleSizes.push(await this.stream.getNextUint32());\n      }\n    }\n\n    return {\n      header,\n      type: \"stsz\",\n      fullBoxHeader,\n      sampleSizes,\n      sampleCount,\n    };\n  }\n}\n\nclass SttsBoxParser extends FullBoxParser<SttsBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<SttsBox> {\n    const entryCount = await this.stream.getNextUint32();\n    const entries = [];\n    for (let i = 0; i < entryCount; i++) {\n      entries.push({\n        sampleCount: await this.stream.getNextUint32(),\n        sampleDelta: await this.stream.getNextUint32(),\n      });\n    }\n\n    return {\n      header,\n      type: \"stts\",\n      fullBoxHeader,\n      entries,\n    };\n  }\n}\n\nclass UdtaBoxParser extends SimpleBoxParser<UdtaBox> {\n  async parseBox(header: BoxHeader): Promise<UdtaBox> {\n    // TODO: Not fully parsed.\n    await this.getChildBoxes();\n\n    return {\n      header,\n      type: \"udta\",\n    };\n  }\n}\n\nclass HdrlBoxParser extends FullBoxParser<HdlrBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<HdlrBox> {\n    await this.stream.getNextUint32(); // Predefined\n\n    const handlerType = await this.stream.getNextString(4); // Handler type\n\n    for (let i = 0; i < 3; i++) {\n      await this.stream.getNextUint32(); // Reserved\n    }\n\n    const name = await this.stream.getNextString();\n\n    return {\n      header,\n      fullBoxHeader,\n      type: \"hdlr\",\n      handlerType,\n      name,\n    };\n  }\n}\n\nclass VmhdBoxParser extends FullBoxParser<VmhdBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<VmhdBox> {\n    const graphicsMode = await this.stream.getNextUint16();\n    const opColor = [\n      await this.stream.getNextUint16(),\n      await this.stream.getNextUint16(),\n      await this.stream.getNextUint16(),\n    ];\n\n    return {\n      header,\n      fullBoxHeader,\n      type: \"vmhd\",\n      graphicsMode,\n      opColor,\n    };\n  }\n}\n\nclass DrefBoxParser extends FullBoxParser<DrefBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<DrefBox> {\n    const entryCount = await this.stream.getNextUint32();\n    const entries = [];\n    for (let i = 0; i < entryCount; i++) {\n      entries.push((await this.getNextChildBox()) as UrlBox | UrnBox);\n    }\n\n    return {\n      header,\n      fullBoxHeader,\n      type: \"dref\",\n      entries,\n    };\n  }\n}\n\nclass DinfBoxParser extends SimpleBoxParser<DinfBox> {\n  async parseBox(header: BoxHeader): Promise<DinfBox> {\n    const childBoxes = await this.getChildBoxes();\n\n    return {\n      header,\n      type: \"dinf\",\n      dref: childBoxes.dref![0] as DrefBox,\n    };\n  }\n}\n\nclass UrnBoxParser extends FullBoxParser<UrnBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<UrnBox> {\n    let name: string = \"\";\n    let location: string = \"\";\n    if (fullBoxHeader.flags !== 1) {\n      name = await this.stream.getNextString();\n      location = await this.stream.getNextString();\n    }\n\n    return {\n      header,\n      fullBoxHeader,\n      type: \"urn \",\n      name,\n      location,\n    };\n  }\n}\n\nclass UrlBoxParser extends FullBoxParser<UrlBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<UrlBox> {\n    let location: string = \"\";\n    if (fullBoxHeader.flags !== 1) {\n      location = await this.stream.getNextString();\n    }\n\n    return {\n      header,\n      fullBoxHeader,\n      type: \"url \",\n      location,\n    };\n  }\n}\n\nclass UnknownBoxParser extends SimpleBoxParser<UnknownBox> {\n  async parseBox(header: BoxHeader): Promise<UnknownBox> {\n    this.stream.seek(this.header.endOffset);\n\n    return {\n      header,\n      type: \"unknown\",\n    };\n  }\n}\n","import { FileStreamWriter } from \"./io/writer\";\nimport {\n  Avc1Box,\n  AvcCBox,\n  BaseBox,\n  BaseFullBox,\n  Box,\n  DinfBox,\n  DrefBox,\n  FtypBox,\n  HdlrBox,\n  MdhdBox,\n  MdiaBox,\n  MinfBox,\n  MoovBox,\n  MvhdBox,\n  StblBox,\n  StcoBox,\n  StscBox,\n  StsdBox,\n  StssBox,\n  StszBox,\n  SttsBox,\n  TkhdBox,\n  TrakBox,\n  UrlBox,\n  UrnBox,\n  VmhdBox,\n} from \"./types\";\n\nexport async function writeBox(\n  stream: FileStreamWriter,\n  box: Box\n): Promise<void> {\n  const boxWriters: Record<\n    string,\n    new (writer: FileStreamWriter) => BoxWriter<Box>\n  > = {\n    \"url \": UrlBoxWriter,\n    \"urn \": UrnBoxWriter,\n    avc1: Avc1BoxWriter,\n    avcC: AvcCBoxWriter,\n    dinf: DinfBoxWriter,\n    dref: DrefBoxWriter,\n    ftyp: FtypBoxWriter,\n    hdlr: HdlrBoxWriter,\n    mdhd: MdhdBoxWriter,\n    mdia: MdiaBoxWriter,\n    minf: MinfBoxWriter,\n    moov: MoovBoxWriter,\n    mvhd: MvhdBoxWriter,\n    stbl: StblBoxWriter,\n    stco: StcoBoxWriter,\n    stsc: StscBoxWriter,\n    stsd: StsdBoxWriter,\n    stss: StssBoxWriter,\n    stsz: StszBoxWriter,\n    stts: SttsBoxWriter,\n    tkhd: TkhdBoxWriter,\n    trak: TrakBoxWriter,\n    vmhd: VmhdBoxWriter,\n  };\n\n  let writer = boxWriters[box.type];\n  if (!writer) {\n    console.warn(\n      `No writer available for %c${box.type}, not writing.`,\n      \"text-decoration: underline\"\n    );\n  }\n\n  await new writer(stream).write(box);\n}\n\nabstract class BoxWriter<T extends BaseBox> {\n  constructor(protected readonly stream: FileStreamWriter) {}\n\n  async write(box: T): Promise<void> {\n    const startOffset = this.stream.offset;\n    await this.stream.writeNextUint32(0);\n    await this.stream.writeNextString(box.type, 4);\n\n    await this.writeContents(box);\n\n    const endOffset = this.stream.offset;\n    const size = endOffset - startOffset;\n    await this.stream.seek(startOffset);\n    await this.stream.writeNextUint32(size);\n\n    await this.stream.seek(endOffset);\n  }\n\n  abstract writeContents(box: T): Promise<void>;\n}\n\nabstract class FullBoxWriter<T extends BaseFullBox> extends BoxWriter<T> {\n  async writeContents(box: T): Promise<void> {\n    await this.stream.writeNextUint8(box.fullBoxHeader!.version);\n\n    await this.stream.writeNextUint8(box.fullBoxHeader!.flags >> 16);\n    await this.stream.writeNextUint8(box.fullBoxHeader!.flags >> 8);\n    await this.stream.writeNextUint8(box.fullBoxHeader!.flags);\n  }\n}\n\nexport class FtypBoxWriter extends BoxWriter<FtypBox> {\n  async writeContents(box: FtypBox): Promise<void> {\n    await this.stream.writeNextString(box.majorBrand, 4);\n    await this.stream.writeNextUint32(box.minorVersion);\n\n    for (const compatibleBrand of box.compatibleBrands) {\n      await this.stream.writeNextString(compatibleBrand, 4);\n    }\n  }\n}\n\nexport class AvcCBoxWriter extends BoxWriter<AvcCBox> {\n  async writeContents(box: AvcCBox): Promise<void> {\n    await this.stream.writeNextUint8(box.configurationVersion);\n\n    await this.stream.writeNextUint8(box.profileIndication);\n    await this.stream.writeNextUint8(box.profileCompatibility);\n    await this.stream.writeNextUint8(box.levelIndication);\n    await this.stream.writeNextUint8(box.lengthSizeMinusOne | 0xfc);\n\n    await this.stream.writeNextUint8(box.sequenceParameterSets.length | 0xe0);\n    for (const sequenceParameterSet of box.sequenceParameterSets) {\n      await this.stream.writeNextUint16(sequenceParameterSet.byteLength);\n      await this.stream.writeNextBytes(sequenceParameterSet);\n    }\n\n    await this.stream.writeNextUint8(box.pictureParameterSets.length);\n    for (const pictureParameterSets of box.pictureParameterSets) {\n      await this.stream.writeNextUint16(pictureParameterSets.byteLength);\n      await this.stream.writeNextBytes(pictureParameterSets);\n    }\n  }\n}\n\nexport class Avc1BoxWriter extends BoxWriter<Avc1Box> {\n  // TODO: Generalise as a SampleEntryBoxWriter\n\n  async writeContents(box: Avc1Box): Promise<void> {\n    // From SampleEntry\n    await this.stream.skip(6);\n    await this.stream.writeNextUint16(box.dataReferenceIndex);\n\n    // From VisualSampleEntry\n    await this.stream.skip(2 * 2 + 4 * 3);\n\n    await this.stream.writeNextUint16(box.width);\n    await this.stream.writeNextUint16(box.height);\n\n    await this.stream.writeNextUint32(box.horizontalResolution);\n    await this.stream.writeNextUint32(box.verticalResolution);\n\n    await this.stream.skip(4);\n\n    await this.stream.writeNextUint16(box.frameCount);\n    await this.stream.writeNextString(box.compressorName, 32);\n    await this.stream.writeNextUint16(box.depth);\n\n    await this.stream.writeNextUint16(0xffff);\n\n    // From AVCSampleEntry\n    await writeBox(this.stream, box.avcC);\n  }\n}\n\nexport class StsdBoxWriter extends FullBoxWriter<StsdBox> {\n  async writeContents(box: StsdBox): Promise<void> {\n    await super.writeContents(box);\n\n    await this.stream.writeNextUint32(box.entries.length);\n    for (const entry of box.entries) {\n      await writeBox(this.stream, entry);\n    }\n  }\n}\n\nexport class StblBoxWriter extends BoxWriter<StblBox> {\n  async writeContents(box: StblBox): Promise<void> {\n    if (box.stco && box.co64) {\n      throw new Error(\"stbl box cannot contain both stco and co64\");\n    }\n\n    if (box.stco) {\n      await writeBox(this.stream, box.stco);\n    } else if (box.co64) {\n      await writeBox(this.stream, box.co64);\n    }\n\n    await writeBox(this.stream, box.stsc);\n    await writeBox(this.stream, box.stsd);\n    await writeBox(this.stream, box.stss);\n    await writeBox(this.stream, box.stsz);\n    await writeBox(this.stream, box.stts);\n  }\n}\n\nexport class UrlBoxWriter extends FullBoxWriter<UrlBox> {\n  async writeContents(box: UrlBox): Promise<void> {\n    await super.writeContents(box);\n\n    if (box.fullBoxHeader!.flags !== 1) {\n      await this.stream.writeNextString(box.location);\n    }\n  }\n}\n\nexport class UrnBoxWriter extends FullBoxWriter<UrnBox> {\n  async writeContents(box: UrnBox): Promise<void> {\n    await super.writeContents(box);\n\n    if (box.fullBoxHeader!.flags !== 1) {\n      await this.stream.writeNextString(box.name);\n      await this.stream.writeNextString(box.location);\n    }\n  }\n}\n\nexport class DinfBoxWriter extends BoxWriter<DinfBox> {\n  async writeContents(box: DinfBox): Promise<void> {\n    await writeBox(this.stream, box.dref);\n  }\n}\n\nexport class DrefBoxWriter extends FullBoxWriter<DrefBox> {\n  async writeContents(box: DrefBox): Promise<void> {\n    await super.writeContents(box);\n\n    await this.stream.writeNextUint32(box.entries.length);\n    for (const entry of box.entries) {\n      await writeBox(this.stream, entry);\n    }\n  }\n}\n\nexport class VmhdBoxWriter extends FullBoxWriter<VmhdBox> {\n  async writeContents(box: VmhdBox): Promise<void> {\n    await super.writeContents(box);\n\n    await this.stream.writeNextUint16(box.graphicsMode);\n    for (const color of box.opColor) {\n      await this.stream.writeNextUint16(color);\n    }\n  }\n}\n\nexport class HdlrBoxWriter extends FullBoxWriter<HdlrBox> {\n  async writeContents(box: HdlrBox): Promise<void> {\n    await super.writeContents(box);\n\n    await this.stream.skip(4);\n    await this.stream.writeNextString(box.handlerType, 4);\n    await this.stream.skip(4 * 3);\n    await this.stream.writeNextString(box.name);\n  }\n}\n\nexport class StcoBoxWriter extends FullBoxWriter<StcoBox> {\n  async writeContents(box: StcoBox): Promise<void> {\n    await super.writeContents(box);\n\n    await this.stream.writeNextUint32(box.chunkOffsets.length);\n    for (const chunkOffset of box.chunkOffsets) {\n      await this.stream.writeNextUint32(chunkOffset);\n    }\n  }\n}\n\nexport class StszBoxWriter extends FullBoxWriter<StszBox> {\n  async writeContents(box: StszBox): Promise<void> {\n    await super.writeContents(box);\n\n    await this.stream.writeNextUint32(\n      box.sampleSizes.length > 1 ? 0 : box.sampleSizes[0]\n    );\n    await this.stream.writeNextUint32(box.sampleCount);\n    for (const sampleSize of box.sampleSizes) {\n      await this.stream.writeNextUint32(sampleSize);\n    }\n  }\n}\n\nexport class StscBoxWriter extends FullBoxWriter<StscBox> {\n  async writeContents(box: StscBox): Promise<void> {\n    await super.writeContents(box);\n\n    await this.stream.writeNextUint32(box.entries.length);\n    for (const entry of box.entries) {\n      await this.stream.writeNextUint32(entry.firstChunk);\n      await this.stream.writeNextUint32(entry.samplesPerChunk);\n      await this.stream.writeNextUint32(entry.sampleDescriptionIndex);\n    }\n  }\n}\n\nexport class SttsBoxWriter extends FullBoxWriter<SttsBox> {\n  async writeContents(box: SttsBox): Promise<void> {\n    await super.writeContents(box);\n\n    await this.stream.writeNextUint32(box.entries.length);\n    for (const entry of box.entries) {\n      await this.stream.writeNextUint32(entry.sampleCount);\n      await this.stream.writeNextUint32(entry.sampleDelta);\n    }\n  }\n}\n\nexport class StssBoxWriter extends FullBoxWriter<StssBox> {\n  async writeContents(box: StssBox): Promise<void> {\n    await super.writeContents(box);\n\n    await this.stream.writeNextUint32(box.sampleNumbers.length);\n    for (const sampleNumber of box.sampleNumbers) {\n      await this.stream.writeNextUint32(sampleNumber);\n    }\n  }\n}\n\nexport class MdhdBoxWriter extends FullBoxWriter<MdhdBox> {\n  async writeContents(box: MdhdBox): Promise<void> {\n    await super.writeContents(box);\n\n    await this.stream.writeNextUint32(box.creationTime);\n    await this.stream.writeNextUint32(box.modificationTime);\n    await this.stream.writeNextUint32(box.timescale);\n    await this.stream.writeNextUint32(box.duration);\n\n    // TODO: language\n    await this.stream.skip(2);\n    await this.stream.skip(2);\n  }\n}\n\nexport class TkhdBoxWriter extends FullBoxWriter<TkhdBox> {\n  async writeContents(box: TkhdBox): Promise<void> {\n    await super.writeContents(box);\n\n    await this.stream.writeNextUint32(box.creationTime);\n    await this.stream.writeNextUint32(box.modificationTime);\n    await this.stream.writeNextUint32(box.trackId);\n\n    await this.stream.skip(4);\n\n    await this.stream.writeNextUint32(box.duration);\n\n    await this.stream.skip(4 * 2);\n\n    await this.stream.writeNextUint16(box.layer);\n    await this.stream.writeNextUint16(box.alternateGroup);\n    await this.stream.writeNextUint16(box.volume);\n\n    await this.stream.skip(2);\n\n    for (const matrix of box.matrix) {\n      await this.stream.writeNextUint32(matrix);\n    }\n\n    await this.stream.writeNextUint32(box.width);\n    await this.stream.writeNextUint32(box.height);\n  }\n}\n\nexport class MvhdBoxWriter extends FullBoxWriter<MvhdBox> {\n  async writeContents(box: MvhdBox): Promise<void> {\n    await super.writeContents(box);\n\n    await this.stream.writeNextUint32(box.creationTime);\n    await this.stream.writeNextUint32(box.modificationTime);\n    await this.stream.writeNextUint32(box.timescale);\n    await this.stream.writeNextUint32(box.duration);\n\n    await this.stream.writeNextUint32(box.rate);\n    await this.stream.writeNextUint16(box.volume);\n\n    await this.stream.skip(2 + 4 * 2);\n\n    for (const matrix of box.matrix) {\n      await this.stream.writeNextUint32(matrix);\n    }\n\n    await this.stream.skip(4 * 6);\n\n    await this.stream.writeNextUint32(box.nextTrackId);\n  }\n}\n\nexport class MinfBoxWriter extends BoxWriter<MinfBox> {\n  async writeContents(box: MinfBox): Promise<void> {\n    await writeBox(this.stream, box.vmhd!);\n    await writeBox(this.stream, box.dinf!);\n    await writeBox(this.stream, box.stbl!);\n  }\n}\n\nexport class MdiaBoxWriter extends BoxWriter<MdiaBox> {\n  async writeContents(box: MdiaBox): Promise<void> {\n    await writeBox(this.stream, box.mdhd!);\n    await writeBox(this.stream, box.hdlr!);\n    await writeBox(this.stream, box.minf!);\n  }\n}\n\nexport class TrakBoxWriter extends BoxWriter<TrakBox> {\n  async writeContents(box: TrakBox): Promise<void> {\n    await writeBox(this.stream, box.tkhd!);\n    await writeBox(this.stream, box.mdia!);\n  }\n}\n\nexport class MoovBoxWriter extends BoxWriter<MoovBox> {\n  async writeContents(box: MoovBox): Promise<void> {\n    await writeBox(this.stream, box.mvhd!);\n    for (const trak of box.trak) {\n      await writeBox(this.stream, trak);\n    }\n  }\n}\n\nexport class MdatBoxStreamWriter {\n  private startOffset: number = 0;\n  private sizeOffset: number = 0;\n\n  private opened = false;\n  private closed = false;\n\n  constructor(private readonly stream: FileStreamWriter) {}\n\n  async open() {\n    if (this.opened) {\n      throw new Error(\"already opened\");\n    } else if (this.closed) {\n      throw new Error(\"already closed\");\n    }\n\n    this.startOffset = this.stream.offset;\n    await this.stream.writeNextUint32(1);\n    await this.stream.writeNextString(\"mdat\", 4);\n\n    this.sizeOffset = this.stream.offset;\n    await this.stream.writeNextUint64(0);\n\n    this.opened = true;\n  }\n\n  async write(bytes: Blob | BufferSource): Promise<void> {\n    if (!this.opened) {\n      throw new Error(\"not opened\");\n    } else if (this.closed) {\n      throw new Error(\"already closed\");\n    }\n\n    await this.stream.writeNextBytes(bytes);\n  }\n\n  async close() {\n    if (!this.opened) {\n      throw new Error(\"not opened\");\n    } else if (this.closed) {\n      throw new Error(\"already closed\");\n    }\n\n    const endOffset = this.stream.offset;\n\n    await this.stream.seek(this.sizeOffset);\n    await this.stream.writeNextUint64(endOffset - this.startOffset);\n    await this.stream.seek(endOffset);\n\n    this.closed = true;\n  }\n\n  get dataStartOffset(): number {\n    if (!this.opened) {\n      throw new Error(\"not opened\");\n    }\n\n    return this.startOffset + 16;\n  }\n}\n","import { FileStreamReader } from \"./io/reader\";\nimport { FileStreamWriter } from \"./io/writer\";\nimport {\n  Avc1Box,\n  AvcCBox,\n  Box,\n  DinfBox,\n  DrefBox,\n  FtypBox,\n  HdlrBox,\n  MdatBox,\n  MdhdBox,\n  MdiaBox,\n  MinfBox,\n  MoovBox,\n  MvhdBox,\n  StblBox,\n  StcoBox,\n  StscBox,\n  StsdBox,\n  StssBox,\n  StszBox,\n  SttsBox,\n  TkhdBox,\n  TrakBox,\n  UrlBox,\n  VmhdBox,\n} from \"./types\";\n\nimport { parseBox } from \"./parsers\";\nimport {\n  writeBox, MdatBoxStreamWriter,\n} from \"./writers\";\n\nexport class MP4Parser {\n  private readonly stream: FileStreamReader;\n  mdat?: MdatBox;\n  moov?: MoovBox;\n\n  constructor(file: File) {\n    this.stream = new FileStreamReader(file);\n  }\n\n  async parse(): Promise<void> {\n    const ftyp = await this.parseBox();\n    if (ftyp.type !== \"ftyp\") {\n      throw new Error(\"Expected ftyp box at start of file. Not an MP4?\");\n    }\n\n    let mdat: MdatBox | undefined;\n    let moov: MoovBox | undefined;\n\n    while (!this.stream.eof) {\n      const box = await this.parseBox();\n\n      switch (box.type) {\n        case \"mdat\":\n          mdat = box;\n          break;\n        case \"moov\":\n          moov = box;\n          break;\n        default:\n          break;\n      }\n    }\n\n    if (!mdat || !moov) {\n      throw new Error(\"Missing mdat or moov box\");\n    }\n\n    this.mdat = mdat;\n    this.moov = moov;\n  }\n\n  async getSample(sampleNumber: number): Promise<{\n    data: Uint8Array;\n    sync: boolean;\n  }> {\n    const stbl = this.moov!.trak[0].mdia.minf.stbl;\n    const stsz = stbl.stsz;\n    const stco = stbl.stco ? stbl.stco : stbl.co64;\n\n    const sampleSize = stsz.sampleSizes[sampleNumber];\n\n    let chunkOffset = stco!.chunkOffsets[0];\n    let sampleOffset = chunkOffset;\n    for (let i = 0; i < sampleNumber; i++) {\n      sampleOffset += stbl.stsz.sampleSizes[i];\n    }\n\n    this.stream.seek(sampleOffset);\n    return {\n      data: await this.stream.getNextBytes(sampleSize),\n      sync: this.isSampleSync(sampleNumber),\n    };\n  }\n\n  isSampleSync(sampleNumber: number): boolean {\n    const stbl = this.moov!.trak[0].mdia.minf.stbl;\n    return stbl.stss.sampleNumbers.includes(sampleNumber + 1);\n  }\n\n  private async parseBox(): Promise<Box> {\n    return await parseBox(this.stream);\n  }\n}\n\nexport class MP4Writer {\n  private readonly stream: FileStreamWriter;\n  private readonly mdat: MdatBoxStreamWriter;\n  private avcC?: AvcCBox;\n\n  private sampleCount = 0;\n  private syncSamples: number[] = [];\n  private sampleSizes: number[] = [];\n\n  private displaySize?: { width: number; height: number };\n\n  constructor(file: FileSystemFileHandle) {\n    this.stream = new FileStreamWriter(file);\n    this.mdat = new MdatBoxStreamWriter(this.stream);\n  }\n\n  async open(): Promise<void> {\n    const ftyp: FtypBox = {\n      type: \"ftyp\",\n      majorBrand: \"isom\",\n      minorVersion: 0,\n      compatibleBrands: [\"mp41\", \"avc1\", \"isom\"],\n    };\n\n    await writeBox(this.stream, ftyp);\n    await this.mdat.open();\n  }\n\n  async writeSample(data: Blob | BufferSource, sync: boolean) {\n    await this.mdat.write(data);\n\n    if (sync) {\n      this.syncSamples.push(this.sampleCount + 1);\n    }\n\n    this.sampleSizes.push(data instanceof Blob ? data.size : data.byteLength);\n    this.sampleCount++;\n  }\n\n  setAvcC(avcCStruct: ArrayBuffer | ArrayBufferView) {\n    // TODO: Make a nice stream view for this.\n    let view: DataView;\n    if (avcCStruct instanceof ArrayBuffer) {\n      view = new DataView(avcCStruct);\n    } else {\n      view = new DataView(\n        avcCStruct.buffer,\n        avcCStruct.byteOffset,\n        avcCStruct.byteLength\n      );\n    }\n\n    let avcC: AvcCBox = {\n      type: \"avcC\",\n      configurationVersion: view.getUint8(0),\n      profileIndication: view.getUint8(1),\n      profileCompatibility: view.getUint8(2),\n      levelIndication: view.getUint8(3),\n      lengthSizeMinusOne: view.getUint8(4) & 0x3,\n      sequenceParameterSets: [],\n      pictureParameterSets: [],\n    } as AvcCBox;\n\n    let offset: number = 5;\n\n    const spsCount = view.getUint8(offset) & 0x1f;\n    offset += 1;\n\n    const sps = [];\n    for (let i = 0; i < spsCount; i++) {\n      const spsLength = view.getUint16(offset);\n      offset += 2;\n\n      const spsData = new Uint8Array(\n        view.buffer,\n        view.byteOffset + offset,\n        spsLength\n      );\n      sps.push(spsData);\n      offset += spsLength;\n    }\n\n    const ppsCount = view.getUint8(offset);\n    offset += 1;\n\n    const pps = [];\n    for (let i = 0; i < ppsCount; i++) {\n      const ppsLength = view.getUint16(offset);\n      offset += 2;\n\n      const ppsData = new Uint8Array(\n        view.buffer,\n        view.byteOffset + offset,\n        ppsLength\n      );\n      pps.push(ppsData);\n      offset += ppsLength;\n    }\n\n    avcC.sequenceParameterSets = sps;\n    avcC.pictureParameterSets = pps;\n\n    this.avcC = avcC;\n  }\n\n  setDisplaySize(options: { width: number; height: number }) {\n    this.displaySize = {\n      width: options.width,\n      height: options.height,\n    };\n  }\n\n  async close() {\n    await this.mdat.close();\n\n    const moov: MoovBox = {\n      type: \"moov\",\n      mvhd: this.getMvhdBox(),\n      trak: [this.getTrakBox()],\n    };\n\n    await writeBox(this.stream, moov);\n    await this.stream.close();\n  }\n\n  private getTrakBox(): TrakBox {\n    return {\n      type: \"trak\",\n      tkhd: this.getTkhdBox(),\n      mdia: this.getMdiaBox(),\n    };\n  }\n\n  private getTkhdBox(): TkhdBox {\n    const startDate = new Date(\"1904-01-01T00:00:00Z\");\n    const nowDate = new Date();\n    const diffSeconds = Math.floor(\n      (nowDate.getTime() - startDate.getTime()) / 1000\n    );\n\n    return {\n      type: \"tkhd\",\n      fullBoxHeader: {\n        version: 0,\n        flags: 0x3, // Enabled and in movie\n      },\n      alternateGroup: 0,\n      creationTime: diffSeconds,\n      duration: this.sampleCount * 60,\n      width: this.displaySize!.width,\n      height: this.displaySize!.height,\n      layer: 0,\n      matrix: [0x00010000, 0, 0, 0, 0x00010000, 0, 0, 0, 0x40000000],\n      modificationTime: diffSeconds,\n      trackId: 1,\n      volume: 0,\n    };\n  }\n\n  private getMvhdBox(): MvhdBox {\n    const startDate = new Date(\"1904-01-01T00:00:00Z\");\n    const nowDate = new Date();\n    const diffSeconds = Math.floor(\n      (nowDate.getTime() - startDate.getTime()) / 1000\n    );\n\n    return {\n      type: \"mvhd\",\n      fullBoxHeader: {\n        version: 0,\n        flags: 0,\n      },\n      duration: Math.floor((this.sampleCount * 1000) / 60), // TODO: Make this configurable.\n      creationTime: diffSeconds,\n      modificationTime: diffSeconds,\n      timescale: 1000, // TODO: Make this configurable.\n      rate: 0x00010000,\n      volume: 0x0100,\n      matrix: [0x00010000, 0, 0, 0, 0x00010000, 0, 0, 0, 0x40000000],\n      nextTrackId: 2,\n    };\n  }\n\n  private getMdiaBox(): MdiaBox {\n    return {\n      type: \"mdia\",\n      hdlr: {\n        type: \"hdlr\",\n        fullBoxHeader: {\n          version: 0,\n          flags: 0,\n        },\n        handlerType: \"vide\",\n        name: \"VideoHandler\",\n      } as HdlrBox,\n      minf: this.getMinfBox(),\n      mdhd: this.getMdhdBox(),\n    } as MdiaBox;\n  }\n\n  private getMdhdBox(): MdhdBox {\n    const startDate = new Date(\"1904-01-01T00:00:00Z\");\n    const nowDate = new Date();\n    const diffSeconds = Math.floor(\n      (nowDate.getTime() - startDate.getTime()) / 1000\n    );\n\n    return {\n      type: \"mdhd\",\n      fullBoxHeader: {\n        version: 0,\n        flags: 0,\n      },\n      creationTime: diffSeconds,\n      duration: this.sampleCount,\n      language: \"\",\n      modificationTime: diffSeconds,\n      timescale: 60, // TODO: Make this configurable.\n    };\n  }\n\n  private getMinfBox(): MinfBox {\n    const stbl = this.getStblBox();\n    const dinf = this.getDinfBox();\n\n    return {\n      type: \"minf\",\n      dinf,\n      stbl,\n      vmhd: {\n        type: \"vmhd\",\n        fullBoxHeader: {\n          version: 0,\n          flags: 1,\n        },\n        graphicsMode: 0,\n        opColor: [0, 0, 0],\n      } as VmhdBox,\n    };\n  }\n\n  private getDinfBox(): DinfBox {\n    // Always reports that the data is in the same file.\n    return {\n      type: \"dinf\",\n      dref: {\n        type: \"dref\",\n        fullBoxHeader: {\n          version: 0,\n          flags: 0,\n        },\n        entries: [\n          {\n            type: \"url \",\n            fullBoxHeader: {\n              version: 0,\n              flags: 1,\n            },\n            location: \"\",\n          } as UrlBox,\n        ],\n      } as DrefBox,\n    } as DinfBox;\n  }\n\n  private getStblBox(): StblBox {\n    const stco: StcoBox = {\n      type: \"stco\",\n      fullBoxHeader: {\n        version: 0,\n        flags: 0,\n      },\n      chunkOffsets: [this.mdat.dataStartOffset],\n    };\n\n    const stsc: StscBox = {\n      type: \"stsc\",\n      fullBoxHeader: {\n        version: 0,\n        flags: 0,\n      },\n      entries: [\n        {\n          firstChunk: 1,\n          samplesPerChunk: this.sampleCount,\n          sampleDescriptionIndex: 1,\n        },\n      ],\n    };\n\n    const stsd: StsdBox = {\n      type: \"stsd\",\n      fullBoxHeader: {\n        version: 0,\n        flags: 0,\n      },\n      entries: [\n        {\n          type: \"avc1\",\n          dataReferenceIndex: 1,\n          width: this.displaySize!.width, // TODO: Get from worker.\n          height: this.displaySize!.height,\n          horizontalResolution: 0x00480000,\n          verticalResolution: 0x00480000,\n          frameCount: 1,\n          compressorName: \"mp4.ts\",\n          depth: 24,\n          avcC: this.avcC!,\n        } as Avc1Box,\n      ],\n    };\n\n    const stss: StssBox = {\n      type: \"stss\",\n      fullBoxHeader: {\n        version: 0,\n        flags: 0,\n      },\n      sampleNumbers: this.syncSamples,\n    };\n\n    const stsz: StszBox = {\n      type: \"stsz\",\n      fullBoxHeader: {\n        version: 0,\n        flags: 0,\n      },\n      sampleCount: this.sampleCount,\n      sampleSizes: this.sampleSizes,\n    };\n\n    const stts: SttsBox = {\n      type: \"stts\",\n      fullBoxHeader: {\n        version: 0,\n        flags: 0,\n      },\n      entries: [\n        {\n          sampleCount: this.sampleCount,\n          sampleDelta: 1, // TODO: What if it ain't though?\n        },\n      ],\n    };\n\n    const stbl: StblBox = {\n      type: \"stbl\",\n      stco,\n      stsc,\n      stsd,\n      stss,\n      stsz,\n      stts,\n    };\n\n    return stbl;\n  }\n}\n","import VideoWorkerShared from \"./shared\";\nimport { StreamDataView } from \"stream-data-view\";\nimport {\n  MP4Parser, MP4Writer,\n} from \"./mp4\";\nimport {\n  Avc1Box, AvcCBox,\n} from \"./mp4/types\";\n\nconst MAX_QUEUE_SIZE = 60;\nconst KEYFRAME_INTERVAL = 15;\nconst TINY_FRAME_SIZE = 100;\n\nfunction avcCBoxToDescription(avcCBox: AvcCBox): ArrayBuffer {\n  const stream = new StreamDataView(undefined, true);\n\n  stream.setNextUint8(avcCBox.configurationVersion);\n  stream.setNextUint8(avcCBox.profileIndication);\n  stream.setNextUint8(avcCBox.profileCompatibility);\n  stream.setNextUint8(avcCBox.levelIndication);\n  stream.setNextUint8(avcCBox.lengthSizeMinusOne + (63 << 2));\n\n  stream.setNextUint8(avcCBox.sequenceParameterSets.length + (7 << 5));\n  for (let i = 0; i < avcCBox.sequenceParameterSets.length; i++) {\n    stream.setNextUint16(avcCBox.sequenceParameterSets[i].length);\n    for (let j = 0; j < avcCBox.sequenceParameterSets[i].length; j++) {\n      stream.setNextUint8(avcCBox.sequenceParameterSets[i][j]);\n    }\n  }\n\n  stream.setNextUint8(avcCBox.pictureParameterSets.length);\n  for (let i = 0; i < avcCBox.pictureParameterSets.length; i++) {\n    stream.setNextUint16(avcCBox.pictureParameterSets[i].length);\n    for (let j = 0; j < avcCBox.pictureParameterSets[i].length; j++) {\n      stream.setNextUint8(avcCBox.pictureParameterSets[i][j]);\n    }\n  }\n\n  return stream.getBuffer();\n}\n\ntype InfoReadyCallback = (width: number, height: number) => void;\ntype ModifyFrameCallback = (frame: VideoFrame, index: number) => VideoFrame;\ntype ProgressInitCallback = (total: number) => void;\ntype ProgressCallback = (processed?: number, preview?: ImageBitmap) => void;\n\nexport interface ProcessorOptions {\n  infoReady: InfoReadyCallback;\n  modifyFrame: ModifyFrameCallback;\n  progressInit: ProgressInitCallback;\n  progressUpdate: ProgressCallback;\n}\n\nexport class Processor {\n  decoder?: VideoDecoder;\n  encoder?: VideoEncoder;\n\n  inMp4?: MP4Parser;\n  outMp4?: MP4Writer;\n\n  expectedFrames: number = 0;\n  framesDecoded: number = 0;\n  framesEncoded: number = 0;\n  queuedForDecode: number = 0;\n  queuedForEncode: number = 0;\n\n  infoReady: InfoReadyCallback;\n  modifyFrame: ModifyFrameCallback;\n  progressInit: ProgressInitCallback;\n  progressUpdate: ProgressCallback;\n\n  samplePromise = Promise.resolve();\n  decoderPromise = Promise.resolve();\n  encoderPromise = Promise.resolve();\n\n  constructor(options: ProcessorOptions) {\n    this.infoReady = options.infoReady;\n    this.modifyFrame = options.modifyFrame;\n    this.progressInit = options.progressInit;\n    this.progressUpdate = options.progressUpdate;\n  }\n\n  reset() {\n    if (this.encoder) {\n      this.encoder.close();\n    }\n\n    this.encoder = new VideoEncoder({\n      output: this.handleEncodedFrame.bind(this),\n      error: this.handleEncoderError.bind(this),\n    });\n\n    if (this.decoder) {\n      this.decoder.close();\n    }\n\n    this.decoder = new VideoDecoder({\n      output: this.handleDecodedFrame.bind(this),\n      error: this.handleDecoderError.bind(this),\n    });\n\n    this.samplePromise = Promise.resolve();\n    this.decoderPromise = Promise.resolve();\n    this.encoderPromise = Promise.resolve();\n  }\n\n  async processFile(file: File, outHandle: FileSystemFileHandle) {\n    this.reset();\n\n    this.inMp4 = new MP4Parser(file);\n    await this.inMp4.parse();\n\n    for (const [\n      index,\n      size,\n    ] of this.inMp4.moov!.trak[0].mdia.minf.stbl.stsz.sampleSizes.entries()) {\n      if (size <= TINY_FRAME_SIZE) {\n        console.warn(`Frame ${index} is too small (${size} bytes)!`);\n      }\n    }\n\n    this.outMp4 = new MP4Writer(outHandle);\n    await this.outMp4.open();\n\n    const avc1box = this.inMp4.moov!.trak[0].mdia.minf.stbl.stsd\n      .entries[0] as Avc1Box;\n    const codec =\n      \"avc1.\" +\n      avc1box.avcC.profileIndication.toString(16).padStart(2, \"0\") +\n      avc1box.avcC.profileCompatibility.toString(16).padStart(2, \"0\") +\n      avc1box.avcC.levelIndication.toString(16).padStart(2, \"0\");\n\n    this.decoder!.configure({\n      codec: codec,\n      codedWidth: this.inMp4.moov!.trak[0].tkhd.width,\n      codedHeight: this.inMp4.moov!.trak[0].tkhd.height,\n      description: avcCBoxToDescription(\n        (this.inMp4.moov!.trak[0].mdia.minf.stbl.stsd.entries[0] as Avc1Box)\n          .avcC\n      ),\n      optimizeForLatency: false,\n    });\n\n    this.infoReady(\n      this.inMp4.moov!.trak[0].tkhd.width,\n      this.inMp4.moov!.trak[0].tkhd.height\n    );\n  }\n\n  processSamples(options: { width: number; height: number }) {\n    let bitrate =\n      (this.inMp4!.mdat!.header!.size * 8 * this.inMp4!.moov!.mvhd.timescale) /\n      this.inMp4!.moov!.mvhd.duration;\n    bitrate = Math.ceil(bitrate / 5_000_000) * 5_000_000;\n\n    this.encoder!.configure({\n      codec: \"avc1.42003d\",\n      width: options.width,\n      height: options.height,\n      bitrate: bitrate,\n      framerate: 60,\n      latencyMode: \"quality\",\n    });\n\n    this.outMp4?.setDisplaySize({\n      width: options.width,\n      height: options.height,\n    });\n\n    this.framesDecoded = 0;\n    this.framesEncoded = 0;\n    this.queuedForDecode = 0;\n    this.queuedForEncode = 0;\n    this.expectedFrames = this.inMp4!.moov!.trak[0].mdia.mdhd.duration;\n    this.progressInit(this.expectedFrames);\n\n    this.decodeNextSamples();\n  }\n\n  decodeNextSamples() {\n    this.samplePromise = this.samplePromise.then(async () => {\n      let remainingSamples = this.expectedFrames - this.queuedForDecode;\n      if (remainingSamples <= 0) {\n        // console.debug(\"No more samples to decode\");\n        return;\n      } else {\n        // console.debug(`Remaining samples: ${remainingSamples}`);\n      }\n\n      // console.debug(\n      //   `Dec queue: ${this.decoder!.decodeQueueSize}, Enc queue: ${\n      //     this.encoder!.encodeQueueSize\n      //   }`\n      // );\n      if (\n        (this.decoder!.decodeQueueSize > MAX_QUEUE_SIZE ||\n          this.encoder!.encodeQueueSize > MAX_QUEUE_SIZE) &&\n        remainingSamples > MAX_QUEUE_SIZE\n      ) {\n        // console.debug(\"Queues too full, not adding more samples\");\n        return;\n      }\n\n      const sample = await this.inMp4!.getSample(this.queuedForDecode);\n      if (sample.data.byteLength <= TINY_FRAME_SIZE) {\n        console.warn(`Skipping tiny frame ${this.queuedForDecode}`);\n        this.queuedForDecode++;\n        this.framesDecoded++;\n        this.queuedForEncode++;\n        this.framesEncoded++;\n        this.decodeNextSamples();\n        return;\n      }\n\n      const chunk = new EncodedVideoChunk({\n        type: sample.sync ? \"key\" : \"delta\",\n        timestamp: 0,\n        duration: 60,\n        data: sample.data.buffer,\n      });\n\n      this.decoder!.decode(chunk);\n      this.queuedForDecode++;\n      remainingSamples--;\n\n      if (this.inMp4?.isSampleSync(this.queuedForDecode)) {\n        // Next frame is a keyframe, so flush.\n        this.decoder!.flush();\n      }\n\n      this.decodeNextSamples();\n    });\n  }\n\n  handleDecodedFrame(frame: VideoFrame) {\n    this.decoderPromise = this.decoderPromise.then(async () => {\n      if (this.framesDecoded % KEYFRAME_INTERVAL === 0) {\n        // console.debug(\n        //   `Flushing encoder at decoded frame ${this.framesDecoded}, keyframe incoming.`\n        // );\n        this.encoder!.flush();\n      }\n\n      const modifiedFrame = this.modifyFrame!(frame, this.framesDecoded);\n      frame.close();\n\n      this.encoder!.encode(modifiedFrame, { keyFrame: this.framesDecoded % KEYFRAME_INTERVAL === 0 });\n\n      this.queuedForEncode++;\n\n      if (this.framesDecoded % KEYFRAME_INTERVAL === 0) {\n        createImageBitmap(modifiedFrame).then((previewBitmap) => {\n          this.progressUpdate(undefined, previewBitmap);\n        });\n      }\n      modifiedFrame.close();\n\n      this.framesDecoded++;\n      if (this.framesDecoded === this.expectedFrames - 1) {\n        // console.debug(\n        //   `Flushing encoder at decoded frame ${this.framesDecoded}, last frame.`\n        // );\n        this.encoder!.flush();\n      }\n    });\n  }\n\n  handleEncodedFrame(\n    chunk: EncodedVideoChunk,\n    metadata: EncodedVideoChunkMetadata\n  ) {\n    this.encoderPromise = this.encoderPromise.then(async () => {\n      if (this.framesEncoded === 0) {\n        this.outMp4!.setAvcC(metadata.decoderConfig?.description!);\n      }\n      this.framesEncoded++;\n\n      // console.debug(`Encoded frame ${this.framesEncoded}`);\n      const buffer = new ArrayBuffer(chunk.byteLength);\n      chunk.copyTo(buffer);\n\n      await this.outMp4!.writeSample(buffer, chunk.type === \"key\");\n      this.progressUpdate(this.framesEncoded);\n\n      if (this.framesEncoded === this.expectedFrames) {\n        await this.outMp4?.close();\n        postMessage({ type: VideoWorkerShared.MessageType.FILE_OUT } as VideoWorkerShared.FileOutMessage);\n      } else {\n        this.decodeNextSamples();\n      }\n    });\n  }\n\n  handleDecoderError(e: Error) {\n    throw e;\n  }\n\n  handleEncoderError(e: Error) {\n    throw e;\n  }\n}\n","export const SD_TILE_WIDTH = 12 * 3;\nexport const SD_TILE_HEIGHT = 18 * 3;\n\nexport const HD_TILE_WIDTH = 12 * 2;\nexport const HD_TILE_HEIGHT = 18 * 2;\n\nexport const TILES_PER_PAGE = 256;\n\nexport interface FontPack {\n  sd1: Font;\n  sd2: Font;\n  hd1: Font;\n  hd2: Font;\n}\n\nexport class Font {\n  readonly name: string;\n  readonly tiles: ImageBitmap[];\n\n  constructor(name: string, tiles: ImageBitmap[]) {\n    this.name = name;\n    this.tiles = tiles;\n  }\n\n  getTile(index: number): ImageBitmap {\n    return this.tiles[index];\n  }\n\n  static async fromFile(file: File): Promise<Font> {\n    const data = await file.arrayBuffer();\n    const isHd = file.name.includes(\"hd\");\n\n    const tileWidth = isHd ? HD_TILE_WIDTH : SD_TILE_WIDTH;\n    const tileHeight = isHd ? HD_TILE_HEIGHT : SD_TILE_HEIGHT;\n\n    const tiles: ImageBitmap[] = [];\n    for (let tileIndex = 0; tileIndex < TILES_PER_PAGE; tileIndex++) {\n      const pixData = new Uint8ClampedArray(\n        data,\n        tileIndex * tileWidth * tileHeight * 4,\n        tileWidth * tileHeight * 4\n      );\n\n      const imageData = new ImageData(pixData, tileWidth, tileHeight);\n      const imageBitmap = await createImageBitmap(imageData);\n      tiles.push(imageBitmap);\n    }\n\n    return new Font(file.name, tiles);\n  }\n\n  static async fromFiles(files: File[]): Promise<FontPack> {\n    const fonts = files.map((file) => Font.fromFile(file));\n    const fontPack = await Promise.all(fonts);\n\n    return {\n      sd1: fontPack.find(\n        (font) => !font.name.includes(\"_2\") && !font.name.includes(\"hd\")\n      )!,\n      sd2: fontPack.find(\n        (font) => font.name.includes(\"_2\") && !font.name.includes(\"hd\")\n      )!,\n      hd1: fontPack.find(\n        (font) => !font.name.includes(\"_2\") && font.name.includes(\"hd\")\n      )!,\n      hd2: fontPack.find(\n        (font) => font.name.includes(\"_2\") && font.name.includes(\"hd\")\n      )!,\n    };\n  }\n}\n","import { StreamDataView } from \"stream-data-view\";\n\ninterface OsdHeader {\n  magic: string;\n  version: number;\n  config: OsdConfig;\n}\n\ninterface OsdConfig {\n  charWidth: number;\n  charHeight: number;\n  fontWidth: number;\n  fontHeight: number;\n  xOffset: number;\n  yOffset: number;\n  fontVariant: number;\n}\n\ninterface OsdFrame {\n  frameNumber: number;\n  frameSize: number;\n  frameData: Uint16Array;\n}\n\nexport class OsdReader {\n  readonly header: OsdHeader;\n  readonly frames: OsdFrame[] = [];\n\n  constructor(data: ArrayBuffer) {\n    const stream = new StreamDataView(data);\n    this.header = {\n      magic: stream.getNextString(7),\n      version: stream.getNextUint16(),\n      config: {\n        charWidth: stream.getNextUint8(),\n        charHeight: stream.getNextUint8(),\n        fontWidth: stream.getNextUint8(),\n        fontHeight: stream.getNextUint8(),\n        xOffset: stream.getNextUint16(),\n        yOffset: stream.getNextUint16(),\n        fontVariant: stream.getNextUint8(),\n      },\n    };\n\n    if (this.header.config.charWidth === 31) {\n      this.header.config.charWidth = 30;\n    }\n\n    while (stream.getOffset() < data.byteLength) {\n      try {\n        const frameNumber = stream.getNextUint32();\n        const frameSize = stream.getNextUint32();\n        const frameData = new Uint16Array(data, stream.getOffset(), frameSize);\n        stream.setOffset(stream.getOffset() + frameSize * 2);\n\n        this.frames.push({\n          frameNumber,\n          frameSize,\n          frameData,\n        });\n      } catch (e) {\n        if (e instanceof RangeError) {\n          console.warn(\"No more data in OSD file, probably truncated due to power loss\");\n          break;\n        }\n      }\n    }\n  }\n\n  static async fromFile(file: File): Promise<OsdReader> {\n    const data = await file.arrayBuffer();\n    return new OsdReader(data);\n  }\n}\n","/// <reference lib=\"webworker\" />\n\nimport VideoWorkerShared from \"./shared\";\nimport { Processor } from \"./processor\";\nimport {\n  Font, FontPack, TILES_PER_PAGE,\n} from \"./fonts\";\nimport { OsdReader } from \"./osd\";\n\nconst MAX_DISPLAY_X = 60;\nconst MAX_DISPLAY_Y = 22;\n\nexport class VideoWorker {\n  readonly processor: Processor;\n  fontPack?: FontPack;\n  osdReader?: OsdReader;\n\n  lastOsdIndex: number = 0;\n\n  wide: boolean = false;\n  hd: boolean = false;\n  outWidth?: number;\n  outHeight?: number;\n\n  osdCanvas?: OffscreenCanvas;\n  osdCtx?: OffscreenCanvasRenderingContext2D;\n  frameCanvas?: OffscreenCanvas;\n  frameCtx?: OffscreenCanvasRenderingContext2D;\n\n  constructor() {\n    this.processor = new Processor({\n      infoReady: this.infoReady.bind(this),\n      modifyFrame: this.modifyFrame.bind(this),\n      progressInit: this.progressInit.bind(this),\n      progressUpdate: this.progressUpdate.bind(this),\n    });\n\n    addEventListener(\"message\", this.onMessage.bind(this)); // eslint-disable-line no-restricted-globals\n  }\n\n  infoReady(width: number, height: number) {\n    if (width === 1280 && height === 720) {\n      this.wide = true;\n    }\n\n    if (this.osdReader!.header.config.fontWidth === 24) {\n      this.hd = true;\n    }\n\n    let outWidth: number;\n    let outHeight: number;\n    if (this.wide || this.hd) {\n      outWidth = 1280;\n      outHeight = 720;\n    } else {\n      outWidth = width;\n      outHeight = height;\n    }\n\n    this.outWidth = outWidth;\n    this.outHeight = outHeight;\n\n    this.osdCanvas = new OffscreenCanvas(\n      this.osdReader!.header.config.fontWidth *\n        this.osdReader!.header.config.charWidth,\n      this.osdReader!.header.config.fontHeight *\n        this.osdReader!.header.config.charHeight\n    );\n    this.osdCtx = this.osdCanvas.getContext(\"2d\")!;\n\n    this.frameCanvas = new OffscreenCanvas(this.outWidth!, this.outHeight!);\n    this.frameCtx = this.frameCanvas.getContext(\"2d\")!;\n\n    this.processor.processSamples({\n      width: outWidth,\n      height: outHeight,\n    });\n  }\n\n  modifyFrame(frame: VideoFrame, frameIndex: number): VideoFrame {\n    const osdCanvas = this.osdCanvas!;\n    const osdCtx = this.osdCtx!;\n    const frameCanvas = this.frameCanvas!;\n    const frameCtx = this.frameCtx!;\n\n    frameCtx.fillStyle = \"black\";\n    frameCtx.fillRect(0, 0, frameCanvas.width, frameCanvas.height);\n    osdCtx.clearRect(0, 0, osdCanvas.width, osdCanvas.height);\n\n    let frameXOffset: number;\n    if (this.hd || this.wide) {\n      frameXOffset = (this.outWidth! - frame.displayWidth) / 2;\n    } else {\n      frameXOffset = 0;\n    }\n    frameCtx.drawImage(frame, frameXOffset, 0);\n\n    if (this.lastOsdIndex < this.osdReader!.frames.length - 1) {\n      const nextOsdIndex = this.lastOsdIndex + 1;\n      const nextOsdFrame = this.osdReader!.frames[nextOsdIndex];\n\n      if (frameIndex >= nextOsdFrame.frameNumber) {\n        this.lastOsdIndex = nextOsdIndex;\n      }\n    }\n\n    const osdFrame = this.osdReader!.frames[this.lastOsdIndex];\n    for (let y = 0; y < MAX_DISPLAY_Y; y++) {\n      for (let x = 0; x < MAX_DISPLAY_X; x++) {\n        const osdFrameIndex = y + MAX_DISPLAY_Y * x;\n        const osdFrameChar = osdFrame.frameData[osdFrameIndex];\n\n        let font: Font;\n        if (this.hd) {\n          font =\n            osdFrameChar < TILES_PER_PAGE\n              ? this.fontPack!.hd1\n              : this.fontPack!.hd2;\n        } else {\n          font =\n            osdFrameChar < TILES_PER_PAGE\n              ? this.fontPack!.sd1\n              : this.fontPack!.sd2;\n        }\n\n        osdCtx.drawImage(\n          font.getTile(osdFrameChar % TILES_PER_PAGE),\n          x * this.osdReader!.header.config.fontWidth,\n          y * this.osdReader!.header.config.fontHeight\n        );\n      }\n    }\n\n    // Try fit vertically, then try horizontally.\n    let osdScale: number;\n    if (\n      frameCanvas.height / osdCanvas.height <\n      frameCanvas.width / osdCanvas.width\n    ) {\n      osdScale = frameCanvas.height / osdCanvas.height;\n    } else {\n      osdScale = frameCanvas.width / osdCanvas.width;\n    }\n\n    const osdWidth = osdCanvas.width * osdScale;\n    const osdHeight = osdCanvas.height * osdScale;\n\n    const osdXOffset = (frameCanvas.width - osdWidth) / 2;\n    const osdYOffset = (frameCanvas.height - osdHeight) / 2;\n\n    frameCtx.drawImage(osdCanvas, osdXOffset, osdYOffset, osdWidth, osdHeight);\n\n    return new VideoFrame(frameCanvas as any, { timestamp: frame.timestamp! });\n  }\n\n  progressInit(expectedFrames: number) {\n    postMessage({\n      type: VideoWorkerShared.MessageType.PROGRESS_INIT,\n      expectedFrames,\n    });\n  }\n\n  progressUpdate(currentFrame?: number, preview?: ImageBitmap) {\n    postMessage(\n      {\n        type: VideoWorkerShared.MessageType.PROGRESS_UPDATE,\n        currentFrame,\n        preview,\n      },\n      [...(preview ? [preview] : [])]\n    );\n  }\n\n  async onMessage(event: MessageEvent<VideoWorkerShared.Message>) {\n    const message = event.data;\n    switch (message.type) {\n      case VideoWorkerShared.MessageType.FILE_IN: {\n        this.osdReader = await OsdReader.fromFile(message.osdFile);\n        this.fontPack = await Font.fromFiles(message.fontFiles);\n        await this.processor.processFile(message.videoFile, message.outHandle);\n        break;\n      }\n\n      default: {\n        throw new Error(\"Unknown message type received\");\n      }\n    }\n  }\n}\n\nnew VideoWorker();\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [923], function() { return __webpack_require__(451); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n\tvar getter = module && module.__esModule ?\n\t\tfunction() { return module['default']; } :\n\t\tfunction() { return module; };\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"c2012502\" + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","__webpack_require__.p = \"/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t451: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkwtfos_configurator\"] = self[\"webpackChunkwtfos_configurator\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn __webpack_require__.e(923).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["MessageType","VideoWorkerShared","FileStreamReader","file","buffer","ArrayBuffer","bufferOffset","_offset","this","length","getNextBytes","bytes","byteBuffer","getNextUint8","byte","push","Uint8Array","decoder","TextDecoder","string","decode","getDataView","view","getUint8","getUint16","getUint32","getBigUint64","result","i","offset","bufferEndOffset","size","fillEndOffset","newBufferOffset","Math","floor","BUFFER_SIZE","newBufferEndOffset","ceil","slice","arrayBuffer","fillBuffer","DataView","byteLength","FileStreamWriter","stream","_size","value","array","writeNextBytes","setUint16","setUint32","BigInt","setBigUint64","undefined","TextEncoder","encodeInto","getStream","write","Blob","seek","close","createWritable","truncate","parseBox","startOffset","getNextUint32","getNextString","type","console","debug","Number","getNextUint64","boxParsers","UrlBoxParser","UrnBoxParser","avc1","Avc1BoxParser","avcC","AvcCBoxParser","co64","Co64BoxParser","dinf","DinfBoxParser","dref","DrefBoxParser","ftyp","FtypBoxParser","hdlr","HdrlBoxParser","mdat","MdatBoxParser","mdhd","MdhdBoxParser","mdia","MdiaBoxParser","minf","MinfBoxParser","moov","MoovBoxParser","mvhd","MvhdBoxParser","stbl","StblBoxParser","stco","StcoBoxParser","stsc","StscBoxParser","stsd","StsdBoxParser","stss","StssBoxParser","stsz","StszBoxParser","stts","SttsBoxParser","tkhd","TkhdBoxParser","trak","TrakBoxParser","udta","UdtaBoxParser","vmhd","VmhdBoxParser","parser","warn","UnknownBoxParser","parse","BoxParser","header","getHeader","endOffset","boxes","getNextChildBox","box","diff","SimpleBoxParser","seekToEnd","FullBoxParser","version","flags","getFullBoxHeader","fullBoxHeader","majorBrand","minorVersion","compatibleBrands","getChildBoxes","childBoxes","Error","creationTime","modificationTime","timescale","duration","rate","getNextUint16","volume","matrix","nextTrackId","trackId","layer","alternateGroup","width","height","language","entryCount","entries","nextChild","dataReferenceIndex","horizontalResolution","verticalResolution","frameCount","compressorName","depth","configurationVersion","profileIndication","profileCompatibility","levelIndication","lengthSizeMinusOne","spsCount","sps","spsLength","spsData","ppsCount","pps","ppsLength","ppsData","sequenceParameterSets","pictureParameterSets","sampleNumbers","chunkOffsets","firstChunk","samplesPerChunk","sampleDescriptionIndex","sampleSizes","sampleCount","sampleDelta","handlerType","name","graphicsMode","opColor","location","writeBox","writer","UrlBoxWriter","UrnBoxWriter","Avc1BoxWriter","AvcCBoxWriter","DinfBoxWriter","DrefBoxWriter","FtypBoxWriter","HdlrBoxWriter","MdhdBoxWriter","MdiaBoxWriter","MinfBoxWriter","MoovBoxWriter","MvhdBoxWriter","StblBoxWriter","StcoBoxWriter","StscBoxWriter","StsdBoxWriter","StssBoxWriter","StszBoxWriter","SttsBoxWriter","TkhdBoxWriter","TrakBoxWriter","VmhdBoxWriter","BoxWriter","writeNextUint32","writeNextString","writeContents","FullBoxWriter","writeNextUint8","compatibleBrand","sequenceParameterSet","writeNextUint16","skip","entry","color","chunkOffset","sampleSize","sampleNumber","MdatBoxStreamWriter","sizeOffset","opened","closed","writeNextUint64","MP4Parser","eof","sampleOffset","isSampleSync","data","sync","includes","MP4Writer","syncSamples","displaySize","open","avcCStruct","byteOffset","options","getMvhdBox","getTrakBox","getTkhdBox","getMdiaBox","startDate","Date","nowDate","diffSeconds","getTime","getMinfBox","getMdhdBox","getStblBox","getDinfBox","dataStartOffset","avcCBoxToDescription","avcCBox","StreamDataView","setNextUint8","setNextUint16","j","getBuffer","Processor","encoder","inMp4","outMp4","expectedFrames","framesDecoded","framesEncoded","queuedForDecode","queuedForEncode","infoReady","modifyFrame","progressInit","progressUpdate","samplePromise","Promise","resolve","decoderPromise","encoderPromise","VideoEncoder","output","handleEncodedFrame","bind","error","handleEncoderError","VideoDecoder","handleDecodedFrame","handleDecoderError","outHandle","reset","index","avc1box","codec","toString","padStart","configure","codedWidth","codedHeight","description","optimizeForLatency","bitrate","framerate","latencyMode","setDisplaySize","decodeNextSamples","then","remainingSamples","decodeQueueSize","encodeQueueSize","getSample","sample","chunk","EncodedVideoChunk","timestamp","flush","frame","modifiedFrame","encode","keyFrame","createImageBitmap","previewBitmap","metadata","setAvcC","decoderConfig","copyTo","writeSample","postMessage","e","TILES_PER_PAGE","Font","tiles","isHd","tileWidth","tileHeight","tileIndex","pixData","Uint8ClampedArray","imageData","ImageData","imageBitmap","files","fonts","map","fromFile","all","fontPack","sd1","find","font","sd2","hd1","hd2","OsdReader","frames","magic","config","charWidth","charHeight","fontWidth","fontHeight","xOffset","yOffset","fontVariant","getOffset","frameNumber","frameSize","frameData","Uint16Array","setOffset","RangeError","VideoWorker","processor","osdReader","lastOsdIndex","wide","hd","outWidth","outHeight","osdCanvas","osdCtx","frameCanvas","frameCtx","addEventListener","onMessage","OffscreenCanvas","getContext","processSamples","frameIndex","frameXOffset","fillStyle","fillRect","clearRect","displayWidth","drawImage","nextOsdIndex","osdScale","osdFrame","y","x","osdFrameIndex","osdFrameChar","getTile","osdWidth","osdHeight","osdXOffset","osdYOffset","VideoFrame","currentFrame","preview","event","message","osdFile","fromFiles","fontFiles","processFile","videoFile","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","call","m","__webpack_exports__","O","deferred","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","Object","keys","every","key","splice","r","n","getter","__esModule","d","a","definition","o","defineProperty","enumerable","get","f","chunkId","reduce","promises","u","miniCssF","obj","prop","prototype","hasOwnProperty","p","installedChunks","importScripts","chunkLoadingGlobal","self","parentChunkLoadingFunction","moreModules","runtime","pop","next"],"sourceRoot":""}