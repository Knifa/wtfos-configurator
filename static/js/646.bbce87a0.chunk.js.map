{"version":3,"file":"static/js/646.bbce87a0.chunk.js","mappings":"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","sources":["osd-overlay/shared.ts","osd-overlay/mp4/io/reader.ts","osd-overlay/mp4/io/writer.ts","osd-overlay/mp4/parsers.ts","osd-overlay/mp4/writers.ts","osd-overlay/mp4/index.ts","osd-overlay/processor.ts","osd-overlay/fonts.ts","osd-overlay/osd.ts","osd-overlay/worker.ts","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/compat get default export","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["import { FontPackFiles } from \"./fonts\";\n\nnamespace VideoWorkerShared {\n  export const enum MessageType {\n    COMPLETE,\n    ERROR,\n    PROGRESS_INIT,\n    PROGRESS_UPDATE,\n    START,\n  }\n\n  export interface CompleteMessage {\n    type: MessageType.COMPLETE;\n  }\n\n  export interface ErrorMessage {\n    type: MessageType.ERROR;\n    error: Error;\n  }\n\n  export interface ProgressInitMessage {\n    type: MessageType.PROGRESS_INIT;\n    expectedFrames: number;\n  }\n\n  export interface ProgressUpdateMessage {\n    type: MessageType.PROGRESS_UPDATE;\n    currentFrame?: number;\n    preview?: ImageBitmap;\n  }\n\n  export interface StartMessage {\n    type: MessageType.START;\n    fontFiles: FontPackFiles,\n    osdFile: File;\n    videoFile: File;\n    outHandle: FileSystemFileHandle;\n  }\n\n  export type Message =\n    | CompleteMessage\n    | ErrorMessage\n    | ProgressInitMessage\n    | ProgressUpdateMessage\n    | StartMessage;\n\n\n\n  export class DecoderError extends Error {\n    constructor(message: string) {\n      super(message);\n      this.name = \"DecoderError\";\n    }\n  }\n\n  export class DecoderConfigureError extends DecoderError {\n    constructor(message: string) {\n      super(message);\n      this.name = \"DecoderConfigureError\";\n    }\n  }\n\n  export class EncoderError extends Error {\n    constructor(message: string) {\n      super(message);\n      this.name = \"EncoderError\";\n    }\n  }\n\n  export class EncoderConfigureError extends EncoderError {\n    constructor(message: string) {\n      super(message);\n      this.name = \"EncoderConfigureError\";\n    }\n  }\n\n}\n\nexport default VideoWorkerShared;\n","export class FileStreamReader {\n  private static readonly BUFFER_SIZE = 1024 * 1024 * 8; // 8MB\n\n  private file: File;\n\n  private buffer = new ArrayBuffer(0);\n  private bufferOffset = 0;\n  private _offset = 0;\n\n  constructor(file: File) {\n    this.file = file;\n  }\n\n  async getNextString(length?: number): Promise<string> {\n    let bytes: Uint8Array;\n\n    if (length) {\n      bytes = await this.getNextBytes(length);\n    } else {\n      const byteBuffer = [];\n      let byte: number;\n      while ((byte = await this.getNextUint8()) !== 0) {\n        byteBuffer.push(byte);\n      }\n\n      bytes = new Uint8Array(byteBuffer);\n    }\n\n    const decoder = new TextDecoder();\n    const string = decoder.decode(bytes);\n    return string;\n  }\n\n  async getNextUint8(): Promise<number> {\n    const view = await this.getDataView(1);\n    return view.getUint8(0);\n  }\n\n  async getNextUint16(): Promise<number> {\n    const view = await this.getDataView(2);\n    return view.getUint16(0);\n  }\n\n  async getNextUint32(): Promise<number> {\n    const view = await this.getDataView(4);\n    return view.getUint32(0);\n  }\n\n  async getNextUint64(): Promise<bigint> {\n    const view = await this.getDataView(8);\n    return view.getBigUint64(0);\n  }\n\n  async getNextBytes(length: number): Promise<Uint8Array> {\n    const view = await this.getDataView(length);\n    const result = new Uint8Array(length);\n    for (let i = 0; i < length; i++) {\n      result[i] = view.getUint8(i);\n    }\n\n    return result;\n  }\n\n  seek(offset: number) {\n    this._offset = offset;\n    if (\n      this._offset < this.bufferOffset ||\n      this._offset > this.bufferEndOffset\n    ) {\n      this.buffer = new ArrayBuffer(0);\n      this.bufferOffset = this._offset;\n    }\n  }\n\n  skip(length: number) {\n    this._offset += length;\n  }\n\n  get eof() {\n    return this.offset >= this.file.size;\n  }\n\n  get offset() {\n    return this._offset;\n  }\n\n  get size() {\n    return this.file.size;\n  }\n\n  private async fillBuffer(length: number) {\n    const fillEndOffset = this.offset + length;\n\n    if (fillEndOffset > this.bufferEndOffset) {\n      const newBufferOffset =\n        Math.floor(this.offset / FileStreamReader.BUFFER_SIZE) *\n        FileStreamReader.BUFFER_SIZE;\n      const newBufferEndOffset =\n        Math.ceil(fillEndOffset / FileStreamReader.BUFFER_SIZE) *\n        FileStreamReader.BUFFER_SIZE;\n\n      this.buffer = await this.file\n        .slice(newBufferOffset, newBufferEndOffset)\n        .arrayBuffer();\n      this.bufferOffset = newBufferOffset;\n    }\n  }\n\n  private async getDataView(length: number): Promise<DataView> {\n    await this.fillBuffer(length);\n\n    const result = new DataView(\n      this.buffer,\n      this.offset - this.bufferOffset,\n      length\n    );\n    this._offset += length;\n    return result;\n  }\n\n  private get bufferEndOffset() {\n    return this.bufferOffset + this.buffer.byteLength;\n  }\n}\n","/*\n  TODO:\n  - Keep a consistent buffer going instead of creating a new one every time.\n*/\n\nexport class FileStreamWriter {\n  private readonly file: FileSystemFileHandle;\n  private stream?: FileSystemWritableFileStream;\n\n  private _offset = 0;\n  private _size = 0;\n\n  constructor(file: FileSystemFileHandle) {\n    this.file = file;\n  }\n\n  async writeNextUint8(value: number): Promise<void> {\n    const array = new Uint8Array(1);\n    array[0] = value;\n\n    await this.writeNextBytes(array);\n  }\n\n  async writeNextUint16(value: number): Promise<void> {\n    const buffer = new ArrayBuffer(2);\n    const view = new DataView(buffer);\n    view.setUint16(0, value, false);\n\n    await this.writeNextBytes(buffer);\n  }\n\n  async writeNextUint32(value: number): Promise<void> {\n    const buffer = new ArrayBuffer(4);\n    const view = new DataView(buffer);\n    view.setUint32(0, value, false);\n\n    await this.writeNextBytes(buffer);\n  }\n\n  async writeNextUint64(value: number | bigint): Promise<void> {\n    if (typeof value === \"number\") {\n      value = BigInt(value);\n    }\n\n    const buffer = new ArrayBuffer(8);\n    const view = new DataView(buffer);\n    view.setBigUint64(0, value, false);\n\n    await this.writeNextBytes(buffer);\n  }\n\n  async writeNextString(value: string, length?: number): Promise<void> {\n    const buffer = new Uint8Array(\n      length !== undefined ? length : value.length + 1\n    );\n\n    const encoder = new TextEncoder();\n    encoder.encodeInto(value, buffer);\n\n    await this.writeNextBytes(buffer);\n  }\n\n  async writeNextBytes(bytes: BufferSource | Blob): Promise<void> {\n    const stream = await this.getStream();\n    await stream.write(bytes);\n\n    const byteLength = bytes instanceof Blob ? bytes.size : bytes.byteLength;\n    this._offset += byteLength;\n    this._size += byteLength;\n  }\n\n  async skip(length: number) {\n    await this.seek(this.offset + length);\n  }\n\n  async seek(offset: number) {\n    const stream = await this.getStream();\n    await stream.seek(offset);\n    this._offset = offset;\n  }\n\n  async close() {\n    const stream = await this.getStream();\n    await stream.close();\n    this.stream = undefined;\n  }\n\n  private async getStream(): Promise<FileSystemWritableFileStream> {\n    if (!this.stream) {\n      this.stream = await this.file.createWritable();\n      await this.stream.truncate(0);\n\n      this._size = 0;\n      this._offset = 0;\n    }\n\n    return this.stream;\n  }\n\n  get offset(): number {\n    return this._offset;\n  }\n\n  get size(): number {\n    return this._size;\n  }\n}\n","import { FileStreamReader } from \"./io/reader\";\nimport {\n  Avc1Box,\n  AvcCBox,\n  BaseBox,\n  BaseFullBox,\n  Box,\n  BoxHeader,\n  BoxType,\n  Co64Box,\n  DinfBox,\n  DrefBox,\n  FtypBox,\n  FullBoxHeader,\n  HdlrBox,\n  MdatBox,\n  MdhdBox,\n  MdiaBox,\n  MinfBox,\n  MoovBox,\n  MvhdBox,\n  SampleEntryBox,\n  StblBox,\n  StcoBox,\n  StscBox,\n  StsdBox,\n  StssBox,\n  StszBox,\n  SttsBox,\n  TkhdBox,\n  TrakBox,\n  UdtaBox,\n  UnknownBox,\n  UrlBox,\n  UrnBox,\n  VmhdBox,\n} from \"./types\";\n\nexport async function parseBox(stream: FileStreamReader): Promise<Box> {\n  const startOffset = stream.offset;\n\n  let size = await stream.getNextUint32();\n  const type = await stream.getNextString(4);\n\n  if (size === 0) {\n    size = stream.size - startOffset;\n    console.debug(\n      `${type} box has size 0, must continue until end of file: ${size}`\n    );\n  } else if (size === 1) {\n    // Not actually 64-bits but 9007TB is enough for any one box, I'm sure.\n    size = Number(await stream.getNextUint64());\n    console.debug(`${type} box has big size: ${size}`);\n  }\n\n  const boxParsers: Record<\n    string,\n    new (\n      stream: FileStreamReader,\n      startOffset: number,\n      size: number,\n      type: string\n    ) => BoxParser<Box>\n  > = {\n    \"url \": UrlBoxParser,\n    \"urn \": UrnBoxParser,\n    avc1: Avc1BoxParser,\n    avcC: AvcCBoxParser,\n    co64: Co64BoxParser,\n    dinf: DinfBoxParser,\n    dref: DrefBoxParser,\n    ftyp: FtypBoxParser,\n    hdlr: HdrlBoxParser,\n    mdat: MdatBoxParser,\n    mdhd: MdhdBoxParser,\n    mdia: MdiaBoxParser,\n    minf: MinfBoxParser,\n    moov: MoovBoxParser,\n    mvhd: MvhdBoxParser,\n    stbl: StblBoxParser,\n    stco: StcoBoxParser,\n    stsc: StscBoxParser,\n    stsd: StsdBoxParser,\n    stss: StssBoxParser,\n    stsz: StszBoxParser,\n    stts: SttsBoxParser,\n    tkhd: TkhdBoxParser,\n    trak: TrakBoxParser,\n    udta: UdtaBoxParser,\n    vmhd: VmhdBoxParser,\n  };\n\n  let parser: BoxParser<Box>;\n  if (boxParsers[type]) {\n    parser = new boxParsers[type](stream, startOffset, size, type);\n  } else {\n    console.warn(\n      `No parser available for %c${type}`,\n      \"text-decoration: underline\"\n    );\n    parser = new UnknownBoxParser(stream, startOffset, size, type);\n  }\n\n  return await parser.parse();\n}\n\nabstract class BoxParser<T extends BaseBox> {\n  protected readonly stream: FileStreamReader;\n  protected readonly size: number;\n  protected readonly type: string;\n  protected readonly startOffset: number;\n\n  protected readonly header: BoxHeader;\n\n  constructor(\n    stream: FileStreamReader,\n    startOffset: number,\n    size: number,\n    type: string\n  ) {\n    this.stream = stream;\n    this.startOffset = startOffset;\n    this.size = size;\n    this.type = type;\n\n    this.header = this.getHeader();\n  }\n\n  private getHeader(): BoxHeader {\n    const endOffset = this.startOffset + this.size;\n\n    return {\n      size: this.size,\n      type: this.type,\n\n      startOffset: this.startOffset,\n      endOffset,\n    };\n  }\n\n  protected async getChildBoxes(): Promise<Partial<Record<BoxType, Box[]>>> {\n    const boxes: Partial<Record<BoxType, Box[]>> = {};\n\n    while (this.stream.offset < this.header.endOffset) {\n      const box = await this.getNextChildBox();\n\n      if (box.type === \"unknown\") {\n        console.warn(\n          `Child box %c${box.header!.type}%c in %c${\n            this.type\n          }%c is unknown, ignoring.`,\n          \"text-decoration: underline\",\n          \"text-decoration: none\",\n          \"text-decoration: underline\",\n          \"text-decoration: none\"\n        );\n      }\n\n      if (!(box.type in boxes)) {\n        boxes[box.type] = [];\n      }\n\n      boxes[box.type]!.push(box);\n    }\n\n    return boxes;\n  }\n\n  protected async getNextChildBox(): Promise<Box> {\n    return await parseBox(this.stream);\n  }\n\n  protected seekToEnd(): void {\n    if (this.stream.offset !== this.header.endOffset) {\n      const diff = this.header.endOffset - this.stream.offset;\n      console.warn(\n        `Box %c${this.header.type}%c was not fully parsed! Stopped ${diff}B early.`,\n        \"text-decoration: underline\",\n        \"text-decoration: none\",\n        this.header\n      );\n    }\n\n    this.stream.seek(this.header.endOffset);\n  }\n\n  abstract parse(): Promise<T>;\n}\n\nabstract class SimpleBoxParser<T extends BaseBox> extends BoxParser<T> {\n  async parse(): Promise<T> {\n    const box = await this.parseBox(this.header);\n    this.seekToEnd();\n    return box;\n  }\n\n  protected abstract parseBox(header: BoxHeader): Promise<T>;\n}\n\nabstract class FullBoxParser<T extends BaseFullBox> extends BoxParser<T> {\n  protected async getFullBoxHeader() {\n    const version = await this.stream.getNextUint8();\n    const flags =\n      ((await this.stream.getNextUint8()) << 16) |\n      ((await this.stream.getNextUint8()) << 8) |\n      (await this.stream.getNextUint8());\n\n    return {\n      version,\n      flags,\n    };\n  }\n\n  async parse(): Promise<T> {\n    const fullBoxHeader = await this.getFullBoxHeader();\n    const box = await this.parseBox(this.header, fullBoxHeader);\n    this.seekToEnd();\n    return box;\n  }\n\n  protected abstract parseBox(\n    header: BoxHeader,\n    fullHeader: FullBoxHeader\n  ): Promise<T>;\n}\n\nclass FtypBoxParser extends SimpleBoxParser<FtypBox> {\n  async parseBox(header: BoxHeader): Promise<FtypBox> {\n    const majorBrand = await this.stream.getNextString(4);\n    const minorVersion = await this.stream.getNextUint32();\n    const compatibleBrands = [];\n\n    while (this.stream.offset < header.endOffset) {\n      compatibleBrands.push(await this.stream.getNextString(4));\n    }\n\n    return {\n      type: \"ftyp\",\n      header,\n      majorBrand,\n      minorVersion,\n      compatibleBrands,\n    };\n  }\n}\n\nclass MdatBoxParser extends SimpleBoxParser<MdatBox> {\n  async parseBox(header: BoxHeader): Promise<MdatBox> {\n    this.stream.seek(this.header.endOffset);\n\n    return {\n      type: \"mdat\",\n      header,\n    };\n  }\n}\n\nclass MoovBoxParser extends SimpleBoxParser<MoovBox> {\n  async parseBox(header: BoxHeader): Promise<MoovBox> {\n    const childBoxes = await this.getChildBoxes();\n\n    return {\n      type: \"moov\",\n      header,\n      mvhd: childBoxes.mvhd![0] as MvhdBox,\n      trak: childBoxes.trak as TrakBox[],\n    };\n  }\n}\n\nclass MvhdBoxParser extends FullBoxParser<MvhdBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<MvhdBox> {\n    if (fullBoxHeader.version === 1) {\n      throw new Error(\"Version 1 not supported\");\n    }\n\n    const creationTime = await this.stream.getNextUint32();\n    const modificationTime = await this.stream.getNextUint32();\n    const timescale = await this.stream.getNextUint32();\n    const duration = await this.stream.getNextUint32();\n    const rate = await this.stream.getNextUint32();\n    const volume = await this.stream.getNextUint16();\n\n    // Reserved.\n    await this.stream.getNextUint16();\n    await this.stream.getNextUint32();\n    await this.stream.getNextUint32();\n\n    const matrix = [];\n    for (let i = 0; i < 9; i++) {\n      matrix.push(await this.stream.getNextUint32());\n    }\n\n    // Predefined.\n    for (let i = 0; i < 6; i++) {\n      await this.stream.getNextUint32();\n    }\n\n    const nextTrackId = await this.stream.getNextUint32();\n\n    return {\n      header,\n      type: \"mvhd\",\n      fullBoxHeader,\n      creationTime,\n      modificationTime,\n      timescale,\n      duration,\n      rate,\n      volume,\n      matrix,\n      nextTrackId,\n    };\n  }\n}\n\nclass TrakBoxParser extends SimpleBoxParser<TrakBox> {\n  async parseBox(header: BoxHeader): Promise<TrakBox> {\n    const childBoxes = await this.getChildBoxes();\n\n    return {\n      header,\n      type: \"trak\",\n      tkhd: childBoxes.tkhd![0] as TkhdBox,\n      mdia: childBoxes.mdia![0] as MdiaBox,\n    };\n  }\n}\n\nclass TkhdBoxParser extends FullBoxParser<TkhdBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<TkhdBox> {\n    if (fullBoxHeader.version === 1) {\n      throw new Error(\"Version 1 not supported\");\n    }\n\n    const creationTime = await this.stream.getNextUint32();\n    const modificationTime = await this.stream.getNextUint32();\n    const trackId = await this.stream.getNextUint32();\n    await this.stream.getNextUint32(); // Reserved\n    const duration = await this.stream.getNextUint32();\n\n    await this.stream.getNextUint32(); // Reserved\n    await this.stream.getNextUint32(); // Reserved\n\n    const layer = await this.stream.getNextUint16();\n    const alternateGroup = await this.stream.getNextUint16();\n    const volume = await this.stream.getNextUint16();\n\n    await this.stream.getNextUint16(); // Reserved.\n\n    const matrix = [];\n    for (let i = 0; i < 9; i++) {\n      matrix.push(await this.stream.getNextUint32());\n    }\n\n    let width = (await this.stream.getNextUint32()) >> 16;\n    let height = (await this.stream.getNextUint32()) >> 16;\n\n    return {\n      header,\n      type: \"tkhd\",\n      fullBoxHeader,\n      creationTime,\n      modificationTime,\n      trackId,\n      duration,\n      layer,\n      alternateGroup,\n      volume,\n      matrix,\n      width,\n      height,\n    };\n  }\n}\n\nclass MdiaBoxParser extends SimpleBoxParser<MdiaBox> {\n  async parseBox(header: BoxHeader): Promise<MdiaBox> {\n    const childBoxes = await this.getChildBoxes();\n\n    return {\n      header,\n      type: \"mdia\",\n      mdhd: childBoxes.mdhd![0] as MdhdBox,\n      minf: childBoxes.minf![0] as MinfBox,\n      hdlr: childBoxes.hdlr![0] as HdlrBox,\n    };\n  }\n}\n\nclass MdhdBoxParser extends FullBoxParser<MdhdBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<MdhdBox> {\n    if (fullBoxHeader.version === 1) {\n      throw new Error(\"Version 1 not supported\");\n    }\n\n    let creationTime = await this.stream.getNextUint32();\n    let modificationTime = await this.stream.getNextUint32();\n    let timescale = await this.stream.getNextUint32();\n    let duration = await this.stream.getNextUint32();\n\n    // TODO: Parse this.\n    let language = \"\";\n    await this.stream.getNextUint16();\n\n    await this.stream.getNextUint16(); // Reserved.\n\n    return {\n      header,\n      type: \"mdhd\",\n      fullBoxHeader,\n      creationTime,\n      modificationTime,\n      timescale,\n      duration,\n      language,\n    };\n  }\n}\n\nclass MinfBoxParser extends SimpleBoxParser<MinfBox> {\n  async parseBox(header: BoxHeader): Promise<MinfBox> {\n    const childBoxes = await this.getChildBoxes();\n\n    return {\n      header,\n      type: \"minf\",\n      vmhd: \"vmhd\" in childBoxes ? (childBoxes.vmhd![0] as VmhdBox) : undefined,\n      stbl: childBoxes.stbl![0] as StblBox,\n      dinf: childBoxes.dinf![0] as DinfBox,\n    };\n  }\n}\n\nclass StblBoxParser extends SimpleBoxParser<StblBox> {\n  async parseBox(header: BoxHeader): Promise<StblBox> {\n    const childBoxes = await this.getChildBoxes();\n\n    return {\n      header,\n      type: \"stbl\",\n      stco: childBoxes.stco?.[0] as StcoBox,\n      co64: childBoxes.co64?.[0] as Co64Box,\n      stsc: childBoxes.stsc![0] as StscBox,\n      stsd: childBoxes.stsd![0] as StsdBox,\n      stss: childBoxes.stss![0] as StssBox,\n      stsz: childBoxes.stsz![0] as StszBox,\n      stts: childBoxes.stts![0] as SttsBox,\n    };\n  }\n}\n\nclass StsdBoxParser extends FullBoxParser<StsdBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<StsdBox> {\n    const entryCount = await this.stream.getNextUint32();\n\n    const entries = [];\n    for (let i = 0; i < entryCount; i++) {\n      const nextChild = (await this.getNextChildBox()) as SampleEntryBox;\n      entries.push(nextChild);\n    }\n\n    return {\n      header,\n      type: \"stsd\",\n      fullBoxHeader,\n      entries,\n    };\n  }\n}\n\nclass Avc1BoxParser extends SimpleBoxParser<Avc1Box> {\n  async parseBox(header: BoxHeader): Promise<Avc1Box> {\n    // Reserved\n    for (let i = 0; i < 6; i++) {\n      await this.stream.getNextUint8();\n    }\n\n    const dataReferenceIndex = await this.stream.getNextUint16();\n\n    // Technically from VisualSampleEntry but...\n    for (let i = 0; i < 2; i++) {\n      await this.stream.getNextUint16(); // Reserved\n    }\n    for (let i = 0; i < 3; i++) {\n      await this.stream.getNextUint32(); // Reserved\n    }\n\n    const width = await this.stream.getNextUint16();\n    const height = await this.stream.getNextUint16();\n    const horizontalResolution = await this.stream.getNextUint32();\n    const verticalResolution = await this.stream.getNextUint32();\n\n    await this.stream.getNextUint32(); // Reserved\n\n    const frameCount = await this.stream.getNextUint16();\n    const compressorName = await this.stream.getNextString(32);\n    const depth = await this.stream.getNextUint16();\n\n    await this.stream.getNextUint16(); // Reserved\n\n    const avcC = (await this.getNextChildBox()) as AvcCBox;\n\n    return {\n      header,\n      type: \"avc1\",\n      avcC,\n      compressorName,\n      dataReferenceIndex,\n      depth,\n      frameCount,\n      height,\n      horizontalResolution,\n      verticalResolution,\n      width,\n    };\n  }\n}\n\nclass AvcCBoxParser extends SimpleBoxParser<AvcCBox> {\n  async parseBox(header: BoxHeader): Promise<AvcCBox> {\n    const configurationVersion = await this.stream.getNextUint8();\n    const profileIndication = await this.stream.getNextUint8();\n    const profileCompatibility = await this.stream.getNextUint8();\n    const levelIndication = await this.stream.getNextUint8();\n    const lengthSizeMinusOne = (await this.stream.getNextUint8()) & 0x3;\n\n    const spsCount = (await this.stream.getNextUint8()) & 0x1f;\n    const sps = [];\n    for (let i = 0; i < spsCount; i++) {\n      const spsLength = await this.stream.getNextUint16();\n      const spsData = await this.stream.getNextBytes(spsLength);\n      sps.push(spsData);\n    }\n\n    const ppsCount = await this.stream.getNextUint8();\n    const pps = [];\n    for (let i = 0; i < ppsCount; i++) {\n      const ppsLength = await this.stream.getNextUint16();\n      const ppsData = await this.stream.getNextBytes(ppsLength);\n      pps.push(ppsData);\n    }\n\n    return {\n      header,\n      type: \"avcC\",\n      configurationVersion,\n      profileIndication,\n      profileCompatibility,\n      levelIndication,\n      lengthSizeMinusOne,\n      sequenceParameterSets: sps,\n      pictureParameterSets: pps,\n    };\n  }\n}\n\nclass StssBoxParser extends FullBoxParser<StssBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<StssBox> {\n    const entryCount = await this.stream.getNextUint32();\n    const sampleNumbers = [];\n    for (let i = 0; i < entryCount; i++) {\n      sampleNumbers.push(await this.stream.getNextUint32());\n    }\n\n    return {\n      header,\n      type: \"stss\",\n      fullBoxHeader,\n      sampleNumbers,\n    };\n  }\n}\n\nclass StcoBoxParser extends FullBoxParser<StcoBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<StcoBox> {\n    const entryCount = await this.stream.getNextUint32();\n    const chunkOffsets = [];\n    for (let i = 0; i < entryCount; i++) {\n      chunkOffsets.push(await this.stream.getNextUint32());\n    }\n\n    return {\n      header,\n      type: \"stco\",\n      fullBoxHeader,\n      chunkOffsets,\n    };\n  }\n}\n\nclass Co64BoxParser extends FullBoxParser<Co64Box> {\n  // TODO: Merge with StcoBoxParser?\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<Co64Box> {\n    const entryCount = await this.stream.getNextUint32();\n    const chunkOffsets = [];\n    for (let i = 0; i < entryCount; i++) {\n      chunkOffsets.push(Number(await this.stream.getNextUint64()));\n    }\n\n    return {\n      header,\n      type: \"co64\",\n      fullBoxHeader,\n      chunkOffsets,\n    };\n  }\n}\n\nclass StscBoxParser extends FullBoxParser<StscBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<StscBox> {\n    const entryCount = await this.stream.getNextUint32();\n    const entries = [];\n    for (let i = 0; i < entryCount; i++) {\n      entries.push({\n        firstChunk: await this.stream.getNextUint32(),\n        samplesPerChunk: await this.stream.getNextUint32(),\n        sampleDescriptionIndex: await this.stream.getNextUint32(),\n      });\n    }\n\n    return {\n      header,\n      type: \"stsc\",\n      fullBoxHeader,\n      entries,\n    };\n  }\n}\n\nclass StszBoxParser extends FullBoxParser<StszBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<StszBox> {\n    let sampleSizes = [await this.stream.getNextUint32()];\n    const sampleCount = await this.stream.getNextUint32();\n\n    // If sample size is 0, then we have a table of sample sizes, otherwise\n    // all samples are the same size.\n    if (sampleSizes[0] === 0) {\n      sampleSizes = [];\n      for (let i = 0; i < sampleCount; i++) {\n        sampleSizes.push(await this.stream.getNextUint32());\n      }\n    }\n\n    return {\n      header,\n      type: \"stsz\",\n      fullBoxHeader,\n      sampleSizes,\n      sampleCount,\n    };\n  }\n}\n\nclass SttsBoxParser extends FullBoxParser<SttsBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<SttsBox> {\n    const entryCount = await this.stream.getNextUint32();\n    const entries = [];\n    for (let i = 0; i < entryCount; i++) {\n      entries.push({\n        sampleCount: await this.stream.getNextUint32(),\n        sampleDelta: await this.stream.getNextUint32(),\n      });\n    }\n\n    return {\n      header,\n      type: \"stts\",\n      fullBoxHeader,\n      entries,\n    };\n  }\n}\n\nclass UdtaBoxParser extends SimpleBoxParser<UdtaBox> {\n  async parseBox(header: BoxHeader): Promise<UdtaBox> {\n    // TODO: Not fully parsed.\n    await this.getChildBoxes();\n\n    return {\n      header,\n      type: \"udta\",\n    };\n  }\n}\n\nclass HdrlBoxParser extends FullBoxParser<HdlrBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<HdlrBox> {\n    await this.stream.getNextUint32(); // Predefined\n\n    const handlerType = await this.stream.getNextString(4); // Handler type\n\n    for (let i = 0; i < 3; i++) {\n      await this.stream.getNextUint32(); // Reserved\n    }\n\n    const name = await this.stream.getNextString();\n\n    return {\n      header,\n      fullBoxHeader,\n      type: \"hdlr\",\n      handlerType,\n      name,\n    };\n  }\n}\n\nclass VmhdBoxParser extends FullBoxParser<VmhdBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<VmhdBox> {\n    const graphicsMode = await this.stream.getNextUint16();\n    const opColor = [\n      await this.stream.getNextUint16(),\n      await this.stream.getNextUint16(),\n      await this.stream.getNextUint16(),\n    ];\n\n    return {\n      header,\n      fullBoxHeader,\n      type: \"vmhd\",\n      graphicsMode,\n      opColor,\n    };\n  }\n}\n\nclass DrefBoxParser extends FullBoxParser<DrefBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<DrefBox> {\n    const entryCount = await this.stream.getNextUint32();\n    const entries = [];\n    for (let i = 0; i < entryCount; i++) {\n      entries.push((await this.getNextChildBox()) as UrlBox | UrnBox);\n    }\n\n    return {\n      header,\n      fullBoxHeader,\n      type: \"dref\",\n      entries,\n    };\n  }\n}\n\nclass DinfBoxParser extends SimpleBoxParser<DinfBox> {\n  async parseBox(header: BoxHeader): Promise<DinfBox> {\n    const childBoxes = await this.getChildBoxes();\n\n    return {\n      header,\n      type: \"dinf\",\n      dref: childBoxes.dref![0] as DrefBox,\n    };\n  }\n}\n\nclass UrnBoxParser extends FullBoxParser<UrnBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<UrnBox> {\n    let name: string = \"\";\n    let location: string = \"\";\n    if (fullBoxHeader.flags !== 1) {\n      name = await this.stream.getNextString();\n      location = await this.stream.getNextString();\n    }\n\n    return {\n      header,\n      fullBoxHeader,\n      type: \"urn \",\n      name,\n      location,\n    };\n  }\n}\n\nclass UrlBoxParser extends FullBoxParser<UrlBox> {\n  async parseBox(\n    header: BoxHeader,\n    fullBoxHeader: FullBoxHeader\n  ): Promise<UrlBox> {\n    let location: string = \"\";\n    if (fullBoxHeader.flags !== 1) {\n      location = await this.stream.getNextString();\n    }\n\n    return {\n      header,\n      fullBoxHeader,\n      type: \"url \",\n      location,\n    };\n  }\n}\n\nclass UnknownBoxParser extends SimpleBoxParser<UnknownBox> {\n  async parseBox(header: BoxHeader): Promise<UnknownBox> {\n    this.stream.seek(this.header.endOffset);\n\n    return {\n      header,\n      type: \"unknown\",\n    };\n  }\n}\n","import { FileStreamWriter } from \"./io/writer\";\nimport {\n  Avc1Box,\n  AvcCBox,\n  BaseBox,\n  BaseFullBox,\n  Box,\n  DinfBox,\n  DrefBox,\n  FtypBox,\n  HdlrBox,\n  MdhdBox,\n  MdiaBox,\n  MinfBox,\n  MoovBox,\n  MvhdBox,\n  StblBox,\n  StcoBox,\n  StscBox,\n  StsdBox,\n  StssBox,\n  StszBox,\n  SttsBox,\n  TkhdBox,\n  TrakBox,\n  UrlBox,\n  UrnBox,\n  VmhdBox,\n} from \"./types\";\n\nexport async function writeBox(\n  stream: FileStreamWriter,\n  box: Box\n): Promise<void> {\n  const boxWriters: Record<\n    string,\n    new (writer: FileStreamWriter) => BoxWriter<Box>\n  > = {\n    \"url \": UrlBoxWriter,\n    \"urn \": UrnBoxWriter,\n    avc1: Avc1BoxWriter,\n    avcC: AvcCBoxWriter,\n    dinf: DinfBoxWriter,\n    dref: DrefBoxWriter,\n    ftyp: FtypBoxWriter,\n    hdlr: HdlrBoxWriter,\n    mdhd: MdhdBoxWriter,\n    mdia: MdiaBoxWriter,\n    minf: MinfBoxWriter,\n    moov: MoovBoxWriter,\n    mvhd: MvhdBoxWriter,\n    stbl: StblBoxWriter,\n    stco: StcoBoxWriter,\n    stsc: StscBoxWriter,\n    stsd: StsdBoxWriter,\n    stss: StssBoxWriter,\n    stsz: StszBoxWriter,\n    stts: SttsBoxWriter,\n    tkhd: TkhdBoxWriter,\n    trak: TrakBoxWriter,\n    vmhd: VmhdBoxWriter,\n  };\n\n  let writer = boxWriters[box.type];\n  if (!writer) {\n    console.warn(\n      `No writer available for %c${box.type}, not writing.`,\n      \"text-decoration: underline\"\n    );\n  }\n\n  await new writer(stream).write(box);\n}\n\nabstract class BoxWriter<T extends BaseBox> {\n  constructor(protected readonly stream: FileStreamWriter) {}\n\n  async write(box: T): Promise<void> {\n    const startOffset = this.stream.offset;\n    await this.stream.writeNextUint32(0);\n    await this.stream.writeNextString(box.type, 4);\n\n    await this.writeContents(box);\n\n    const endOffset = this.stream.offset;\n    const size = endOffset - startOffset;\n    await this.stream.seek(startOffset);\n    await this.stream.writeNextUint32(size);\n\n    await this.stream.seek(endOffset);\n  }\n\n  abstract writeContents(box: T): Promise<void>;\n}\n\nabstract class FullBoxWriter<T extends BaseFullBox> extends BoxWriter<T> {\n  async writeContents(box: T): Promise<void> {\n    await this.stream.writeNextUint8(box.fullBoxHeader!.version);\n\n    await this.stream.writeNextUint8(box.fullBoxHeader!.flags >> 16);\n    await this.stream.writeNextUint8(box.fullBoxHeader!.flags >> 8);\n    await this.stream.writeNextUint8(box.fullBoxHeader!.flags);\n  }\n}\n\nexport class FtypBoxWriter extends BoxWriter<FtypBox> {\n  async writeContents(box: FtypBox): Promise<void> {\n    await this.stream.writeNextString(box.majorBrand, 4);\n    await this.stream.writeNextUint32(box.minorVersion);\n\n    for (const compatibleBrand of box.compatibleBrands) {\n      await this.stream.writeNextString(compatibleBrand, 4);\n    }\n  }\n}\n\nexport class AvcCBoxWriter extends BoxWriter<AvcCBox> {\n  async writeContents(box: AvcCBox): Promise<void> {\n    await this.stream.writeNextUint8(box.configurationVersion);\n\n    await this.stream.writeNextUint8(box.profileIndication);\n    await this.stream.writeNextUint8(box.profileCompatibility);\n    await this.stream.writeNextUint8(box.levelIndication);\n    await this.stream.writeNextUint8(box.lengthSizeMinusOne | 0xfc);\n\n    await this.stream.writeNextUint8(box.sequenceParameterSets.length | 0xe0);\n    for (const sequenceParameterSet of box.sequenceParameterSets) {\n      await this.stream.writeNextUint16(sequenceParameterSet.byteLength);\n      await this.stream.writeNextBytes(sequenceParameterSet);\n    }\n\n    await this.stream.writeNextUint8(box.pictureParameterSets.length);\n    for (const pictureParameterSets of box.pictureParameterSets) {\n      await this.stream.writeNextUint16(pictureParameterSets.byteLength);\n      await this.stream.writeNextBytes(pictureParameterSets);\n    }\n  }\n}\n\nexport class Avc1BoxWriter extends BoxWriter<Avc1Box> {\n  // TODO: Generalise as a SampleEntryBoxWriter\n\n  async writeContents(box: Avc1Box): Promise<void> {\n    // From SampleEntry\n    await this.stream.skip(6);\n    await this.stream.writeNextUint16(box.dataReferenceIndex);\n\n    // From VisualSampleEntry\n    await this.stream.skip(2 * 2 + 4 * 3);\n\n    await this.stream.writeNextUint16(box.width);\n    await this.stream.writeNextUint16(box.height);\n\n    await this.stream.writeNextUint32(box.horizontalResolution);\n    await this.stream.writeNextUint32(box.verticalResolution);\n\n    await this.stream.skip(4);\n\n    await this.stream.writeNextUint16(box.frameCount);\n    await this.stream.writeNextString(box.compressorName, 32);\n    await this.stream.writeNextUint16(box.depth);\n\n    await this.stream.writeNextUint16(0xffff);\n\n    // From AVCSampleEntry\n    await writeBox(this.stream, box.avcC);\n  }\n}\n\nexport class StsdBoxWriter extends FullBoxWriter<StsdBox> {\n  async writeContents(box: StsdBox): Promise<void> {\n    await super.writeContents(box);\n\n    await this.stream.writeNextUint32(box.entries.length);\n    for (const entry of box.entries) {\n      await writeBox(this.stream, entry);\n    }\n  }\n}\n\nexport class StblBoxWriter extends BoxWriter<StblBox> {\n  async writeContents(box: StblBox): Promise<void> {\n    if (box.stco && box.co64) {\n      throw new Error(\"stbl box cannot contain both stco and co64\");\n    }\n\n    if (box.stco) {\n      await writeBox(this.stream, box.stco);\n    } else if (box.co64) {\n      await writeBox(this.stream, box.co64);\n    }\n\n    await writeBox(this.stream, box.stsc);\n    await writeBox(this.stream, box.stsd);\n    await writeBox(this.stream, box.stss);\n    await writeBox(this.stream, box.stsz);\n    await writeBox(this.stream, box.stts);\n  }\n}\n\nexport class UrlBoxWriter extends FullBoxWriter<UrlBox> {\n  async writeContents(box: UrlBox): Promise<void> {\n    await super.writeContents(box);\n\n    if (box.fullBoxHeader!.flags !== 1) {\n      await this.stream.writeNextString(box.location);\n    }\n  }\n}\n\nexport class UrnBoxWriter extends FullBoxWriter<UrnBox> {\n  async writeContents(box: UrnBox): Promise<void> {\n    await super.writeContents(box);\n\n    if (box.fullBoxHeader!.flags !== 1) {\n      await this.stream.writeNextString(box.name);\n      await this.stream.writeNextString(box.location);\n    }\n  }\n}\n\nexport class DinfBoxWriter extends BoxWriter<DinfBox> {\n  async writeContents(box: DinfBox): Promise<void> {\n    await writeBox(this.stream, box.dref);\n  }\n}\n\nexport class DrefBoxWriter extends FullBoxWriter<DrefBox> {\n  async writeContents(box: DrefBox): Promise<void> {\n    await super.writeContents(box);\n\n    await this.stream.writeNextUint32(box.entries.length);\n    for (const entry of box.entries) {\n      await writeBox(this.stream, entry);\n    }\n  }\n}\n\nexport class VmhdBoxWriter extends FullBoxWriter<VmhdBox> {\n  async writeContents(box: VmhdBox): Promise<void> {\n    await super.writeContents(box);\n\n    await this.stream.writeNextUint16(box.graphicsMode);\n    for (const color of box.opColor) {\n      await this.stream.writeNextUint16(color);\n    }\n  }\n}\n\nexport class HdlrBoxWriter extends FullBoxWriter<HdlrBox> {\n  async writeContents(box: HdlrBox): Promise<void> {\n    await super.writeContents(box);\n\n    await this.stream.skip(4);\n    await this.stream.writeNextString(box.handlerType, 4);\n    await this.stream.skip(4 * 3);\n    await this.stream.writeNextString(box.name);\n  }\n}\n\nexport class StcoBoxWriter extends FullBoxWriter<StcoBox> {\n  async writeContents(box: StcoBox): Promise<void> {\n    await super.writeContents(box);\n\n    await this.stream.writeNextUint32(box.chunkOffsets.length);\n    for (const chunkOffset of box.chunkOffsets) {\n      await this.stream.writeNextUint32(chunkOffset);\n    }\n  }\n}\n\nexport class StszBoxWriter extends FullBoxWriter<StszBox> {\n  async writeContents(box: StszBox): Promise<void> {\n    await super.writeContents(box);\n\n    await this.stream.writeNextUint32(\n      box.sampleSizes.length > 1 ? 0 : box.sampleSizes[0]\n    );\n    await this.stream.writeNextUint32(box.sampleCount);\n    for (const sampleSize of box.sampleSizes) {\n      await this.stream.writeNextUint32(sampleSize);\n    }\n  }\n}\n\nexport class StscBoxWriter extends FullBoxWriter<StscBox> {\n  async writeContents(box: StscBox): Promise<void> {\n    await super.writeContents(box);\n\n    await this.stream.writeNextUint32(box.entries.length);\n    for (const entry of box.entries) {\n      await this.stream.writeNextUint32(entry.firstChunk);\n      await this.stream.writeNextUint32(entry.samplesPerChunk);\n      await this.stream.writeNextUint32(entry.sampleDescriptionIndex);\n    }\n  }\n}\n\nexport class SttsBoxWriter extends FullBoxWriter<SttsBox> {\n  async writeContents(box: SttsBox): Promise<void> {\n    await super.writeContents(box);\n\n    await this.stream.writeNextUint32(box.entries.length);\n    for (const entry of box.entries) {\n      await this.stream.writeNextUint32(entry.sampleCount);\n      await this.stream.writeNextUint32(entry.sampleDelta);\n    }\n  }\n}\n\nexport class StssBoxWriter extends FullBoxWriter<StssBox> {\n  async writeContents(box: StssBox): Promise<void> {\n    await super.writeContents(box);\n\n    await this.stream.writeNextUint32(box.sampleNumbers.length);\n    for (const sampleNumber of box.sampleNumbers) {\n      await this.stream.writeNextUint32(sampleNumber);\n    }\n  }\n}\n\nexport class MdhdBoxWriter extends FullBoxWriter<MdhdBox> {\n  async writeContents(box: MdhdBox): Promise<void> {\n    await super.writeContents(box);\n\n    await this.stream.writeNextUint32(box.creationTime);\n    await this.stream.writeNextUint32(box.modificationTime);\n    await this.stream.writeNextUint32(box.timescale);\n    await this.stream.writeNextUint32(box.duration);\n\n    // TODO: language\n    await this.stream.skip(2);\n    await this.stream.skip(2);\n  }\n}\n\nexport class TkhdBoxWriter extends FullBoxWriter<TkhdBox> {\n  async writeContents(box: TkhdBox): Promise<void> {\n    await super.writeContents(box);\n\n    await this.stream.writeNextUint32(box.creationTime);\n    await this.stream.writeNextUint32(box.modificationTime);\n    await this.stream.writeNextUint32(box.trackId);\n\n    await this.stream.skip(4);\n\n    await this.stream.writeNextUint32(box.duration);\n\n    await this.stream.skip(4 * 2);\n\n    await this.stream.writeNextUint16(box.layer);\n    await this.stream.writeNextUint16(box.alternateGroup);\n    await this.stream.writeNextUint16(box.volume);\n\n    await this.stream.skip(2);\n\n    for (const matrix of box.matrix) {\n      await this.stream.writeNextUint32(matrix);\n    }\n\n    await this.stream.writeNextUint32(box.width);\n    await this.stream.writeNextUint32(box.height);\n  }\n}\n\nexport class MvhdBoxWriter extends FullBoxWriter<MvhdBox> {\n  async writeContents(box: MvhdBox): Promise<void> {\n    await super.writeContents(box);\n\n    await this.stream.writeNextUint32(box.creationTime);\n    await this.stream.writeNextUint32(box.modificationTime);\n    await this.stream.writeNextUint32(box.timescale);\n    await this.stream.writeNextUint32(box.duration);\n\n    await this.stream.writeNextUint32(box.rate);\n    await this.stream.writeNextUint16(box.volume);\n\n    await this.stream.skip(2 + 4 * 2);\n\n    for (const matrix of box.matrix) {\n      await this.stream.writeNextUint32(matrix);\n    }\n\n    await this.stream.skip(4 * 6);\n\n    await this.stream.writeNextUint32(box.nextTrackId);\n  }\n}\n\nexport class MinfBoxWriter extends BoxWriter<MinfBox> {\n  async writeContents(box: MinfBox): Promise<void> {\n    await writeBox(this.stream, box.vmhd!);\n    await writeBox(this.stream, box.dinf!);\n    await writeBox(this.stream, box.stbl!);\n  }\n}\n\nexport class MdiaBoxWriter extends BoxWriter<MdiaBox> {\n  async writeContents(box: MdiaBox): Promise<void> {\n    await writeBox(this.stream, box.mdhd!);\n    await writeBox(this.stream, box.hdlr!);\n    await writeBox(this.stream, box.minf!);\n  }\n}\n\nexport class TrakBoxWriter extends BoxWriter<TrakBox> {\n  async writeContents(box: TrakBox): Promise<void> {\n    await writeBox(this.stream, box.tkhd!);\n    await writeBox(this.stream, box.mdia!);\n  }\n}\n\nexport class MoovBoxWriter extends BoxWriter<MoovBox> {\n  async writeContents(box: MoovBox): Promise<void> {\n    await writeBox(this.stream, box.mvhd!);\n    for (const trak of box.trak) {\n      await writeBox(this.stream, trak);\n    }\n  }\n}\n\nexport class MdatBoxStreamWriter {\n  private startOffset: number = 0;\n  private sizeOffset: number = 0;\n\n  private opened = false;\n  private closed = false;\n\n  constructor(private readonly stream: FileStreamWriter) {}\n\n  async open() {\n    if (this.opened) {\n      throw new Error(\"already opened\");\n    } else if (this.closed) {\n      throw new Error(\"already closed\");\n    }\n\n    this.startOffset = this.stream.offset;\n    await this.stream.writeNextUint32(1);\n    await this.stream.writeNextString(\"mdat\", 4);\n\n    this.sizeOffset = this.stream.offset;\n    await this.stream.writeNextUint64(0);\n\n    this.opened = true;\n  }\n\n  async write(bytes: Blob | BufferSource): Promise<void> {\n    if (!this.opened) {\n      throw new Error(\"not opened\");\n    } else if (this.closed) {\n      throw new Error(\"already closed\");\n    }\n\n    await this.stream.writeNextBytes(bytes);\n  }\n\n  async close() {\n    if (!this.opened) {\n      throw new Error(\"not opened\");\n    } else if (this.closed) {\n      throw new Error(\"already closed\");\n    }\n\n    const endOffset = this.stream.offset;\n\n    await this.stream.seek(this.sizeOffset);\n    await this.stream.writeNextUint64(endOffset - this.startOffset);\n    await this.stream.seek(endOffset);\n\n    this.closed = true;\n  }\n\n  get dataStartOffset(): number {\n    if (!this.opened) {\n      throw new Error(\"not opened\");\n    }\n\n    return this.startOffset + 16;\n  }\n}\n","import { FileStreamReader } from \"./io/reader\";\nimport { FileStreamWriter } from \"./io/writer\";\nimport {\n  Avc1Box,\n  AvcCBox,\n  Box,\n  DinfBox,\n  DrefBox,\n  FtypBox,\n  HdlrBox,\n  MdatBox,\n  MdhdBox,\n  MdiaBox,\n  MinfBox,\n  MoovBox,\n  MvhdBox,\n  StblBox,\n  StcoBox,\n  StscBox,\n  StsdBox,\n  StssBox,\n  StszBox,\n  SttsBox,\n  TkhdBox,\n  TrakBox,\n  UrlBox,\n  VmhdBox,\n} from \"./types\";\n\nimport { parseBox } from \"./parsers\";\nimport {\n  writeBox, MdatBoxStreamWriter,\n} from \"./writers\";\n\nexport class MP4Parser {\n  private readonly stream: FileStreamReader;\n  mdat?: MdatBox;\n  moov?: MoovBox;\n\n  constructor(file: File) {\n    this.stream = new FileStreamReader(file);\n  }\n\n  async parse(): Promise<void> {\n    const ftyp = await this.parseBox();\n    if (ftyp.type !== \"ftyp\") {\n      throw new Error(\"Expected ftyp box at start of file. Not an MP4?\");\n    }\n\n    let mdat: MdatBox | undefined;\n    let moov: MoovBox | undefined;\n\n    while (!this.stream.eof) {\n      const box = await this.parseBox();\n\n      switch (box.type) {\n        case \"mdat\":\n          mdat = box;\n          break;\n        case \"moov\":\n          moov = box;\n          break;\n        default:\n          break;\n      }\n    }\n\n    if (!mdat || !moov) {\n      throw new Error(\"Missing mdat or moov box\");\n    }\n\n    this.mdat = mdat;\n    this.moov = moov;\n  }\n\n  async getSample(sampleNumber: number): Promise<{\n    data: Uint8Array;\n    sync: boolean;\n  }> {\n    const stbl = this.moov!.trak[0].mdia.minf.stbl;\n    const stsz = stbl.stsz;\n    const stco = stbl.stco ? stbl.stco : stbl.co64;\n\n    const sampleSize = stsz.sampleSizes[sampleNumber];\n\n    let chunkOffset = stco!.chunkOffsets[0];\n    let sampleOffset = chunkOffset;\n    for (let i = 0; i < sampleNumber; i++) {\n      sampleOffset += stbl.stsz.sampleSizes[i];\n    }\n\n    this.stream.seek(sampleOffset);\n    return {\n      data: await this.stream.getNextBytes(sampleSize),\n      sync: this.isSampleSync(sampleNumber),\n    };\n  }\n\n  isSampleSync(sampleNumber: number): boolean {\n    const stbl = this.moov!.trak[0].mdia.minf.stbl;\n    return stbl.stss.sampleNumbers.includes(sampleNumber + 1);\n  }\n\n  private async parseBox(): Promise<Box> {\n    return await parseBox(this.stream);\n  }\n}\n\nexport class MP4Writer {\n  private readonly stream: FileStreamWriter;\n  private readonly mdat: MdatBoxStreamWriter;\n  private avcC?: AvcCBox;\n\n  private sampleCount = 0;\n  private syncSamples: number[] = [];\n  private sampleSizes: number[] = [];\n\n  private displaySize?: { width: number; height: number };\n\n  constructor(file: FileSystemFileHandle) {\n    this.stream = new FileStreamWriter(file);\n    this.mdat = new MdatBoxStreamWriter(this.stream);\n  }\n\n  async open(): Promise<void> {\n    const ftyp: FtypBox = {\n      type: \"ftyp\",\n      majorBrand: \"isom\",\n      minorVersion: 0,\n      compatibleBrands: [\"mp41\", \"avc1\", \"isom\"],\n    };\n\n    await writeBox(this.stream, ftyp);\n    await this.mdat.open();\n  }\n\n  async writeSample(data: Blob | BufferSource, sync: boolean) {\n    await this.mdat.write(data);\n\n    if (sync) {\n      this.syncSamples.push(this.sampleCount + 1);\n    }\n\n    this.sampleSizes.push(data instanceof Blob ? data.size : data.byteLength);\n    this.sampleCount++;\n  }\n\n  setAvcC(avcCStruct: ArrayBuffer | ArrayBufferView) {\n    // TODO: Make a nice stream view for this.\n    let view: DataView;\n    if (avcCStruct instanceof ArrayBuffer) {\n      view = new DataView(avcCStruct);\n    } else {\n      view = new DataView(\n        avcCStruct.buffer,\n        avcCStruct.byteOffset,\n        avcCStruct.byteLength\n      );\n    }\n\n    let avcC: AvcCBox = {\n      type: \"avcC\",\n      configurationVersion: view.getUint8(0),\n      profileIndication: view.getUint8(1),\n      profileCompatibility: view.getUint8(2),\n      levelIndication: view.getUint8(3),\n      lengthSizeMinusOne: view.getUint8(4) & 0x3,\n      sequenceParameterSets: [],\n      pictureParameterSets: [],\n    } as AvcCBox;\n\n    let offset: number = 5;\n\n    const spsCount = view.getUint8(offset) & 0x1f;\n    offset += 1;\n\n    const sps = [];\n    for (let i = 0; i < spsCount; i++) {\n      const spsLength = view.getUint16(offset);\n      offset += 2;\n\n      const spsData = new Uint8Array(\n        view.buffer,\n        view.byteOffset + offset,\n        spsLength\n      );\n      sps.push(spsData);\n      offset += spsLength;\n    }\n\n    const ppsCount = view.getUint8(offset);\n    offset += 1;\n\n    const pps = [];\n    for (let i = 0; i < ppsCount; i++) {\n      const ppsLength = view.getUint16(offset);\n      offset += 2;\n\n      const ppsData = new Uint8Array(\n        view.buffer,\n        view.byteOffset + offset,\n        ppsLength\n      );\n      pps.push(ppsData);\n      offset += ppsLength;\n    }\n\n    avcC.sequenceParameterSets = sps;\n    avcC.pictureParameterSets = pps;\n\n    this.avcC = avcC;\n  }\n\n  setDisplaySize(options: { width: number; height: number }) {\n    this.displaySize = {\n      width: options.width,\n      height: options.height,\n    };\n  }\n\n  async close() {\n    await this.mdat.close();\n\n    const moov: MoovBox = {\n      type: \"moov\",\n      mvhd: this.getMvhdBox(),\n      trak: [this.getTrakBox()],\n    };\n\n    await writeBox(this.stream, moov);\n    await this.stream.close();\n  }\n\n  private getTrakBox(): TrakBox {\n    return {\n      type: \"trak\",\n      tkhd: this.getTkhdBox(),\n      mdia: this.getMdiaBox(),\n    };\n  }\n\n  private getTkhdBox(): TkhdBox {\n    const startDate = new Date(\"1904-01-01T00:00:00Z\");\n    const nowDate = new Date();\n    const diffSeconds = Math.floor(\n      (nowDate.getTime() - startDate.getTime()) / 1000\n    );\n\n    return {\n      type: \"tkhd\",\n      fullBoxHeader: {\n        version: 0,\n        flags: 0x3, // Enabled and in movie\n      },\n      alternateGroup: 0,\n      creationTime: diffSeconds,\n      duration: this.sampleCount * 60,\n      width: this.displaySize!.width,\n      height: this.displaySize!.height,\n      layer: 0,\n      matrix: [0x00010000, 0, 0, 0, 0x00010000, 0, 0, 0, 0x40000000],\n      modificationTime: diffSeconds,\n      trackId: 1,\n      volume: 0,\n    };\n  }\n\n  private getMvhdBox(): MvhdBox {\n    const startDate = new Date(\"1904-01-01T00:00:00Z\");\n    const nowDate = new Date();\n    const diffSeconds = Math.floor(\n      (nowDate.getTime() - startDate.getTime()) / 1000\n    );\n\n    return {\n      type: \"mvhd\",\n      fullBoxHeader: {\n        version: 0,\n        flags: 0,\n      },\n      duration: Math.floor((this.sampleCount * 1000) / 60), // TODO: Make this configurable.\n      creationTime: diffSeconds,\n      modificationTime: diffSeconds,\n      timescale: 1000, // TODO: Make this configurable.\n      rate: 0x00010000,\n      volume: 0x0100,\n      matrix: [0x00010000, 0, 0, 0, 0x00010000, 0, 0, 0, 0x40000000],\n      nextTrackId: 2,\n    };\n  }\n\n  private getMdiaBox(): MdiaBox {\n    return {\n      type: \"mdia\",\n      hdlr: {\n        type: \"hdlr\",\n        fullBoxHeader: {\n          version: 0,\n          flags: 0,\n        },\n        handlerType: \"vide\",\n        name: \"VideoHandler\",\n      } as HdlrBox,\n      minf: this.getMinfBox(),\n      mdhd: this.getMdhdBox(),\n    } as MdiaBox;\n  }\n\n  private getMdhdBox(): MdhdBox {\n    const startDate = new Date(\"1904-01-01T00:00:00Z\");\n    const nowDate = new Date();\n    const diffSeconds = Math.floor(\n      (nowDate.getTime() - startDate.getTime()) / 1000\n    );\n\n    return {\n      type: \"mdhd\",\n      fullBoxHeader: {\n        version: 0,\n        flags: 0,\n      },\n      creationTime: diffSeconds,\n      duration: this.sampleCount,\n      language: \"\",\n      modificationTime: diffSeconds,\n      timescale: 60, // TODO: Make this configurable.\n    };\n  }\n\n  private getMinfBox(): MinfBox {\n    const stbl = this.getStblBox();\n    const dinf = this.getDinfBox();\n\n    return {\n      type: \"minf\",\n      dinf,\n      stbl,\n      vmhd: {\n        type: \"vmhd\",\n        fullBoxHeader: {\n          version: 0,\n          flags: 1,\n        },\n        graphicsMode: 0,\n        opColor: [0, 0, 0],\n      } as VmhdBox,\n    };\n  }\n\n  private getDinfBox(): DinfBox {\n    // Always reports that the data is in the same file.\n    return {\n      type: \"dinf\",\n      dref: {\n        type: \"dref\",\n        fullBoxHeader: {\n          version: 0,\n          flags: 0,\n        },\n        entries: [\n          {\n            type: \"url \",\n            fullBoxHeader: {\n              version: 0,\n              flags: 1,\n            },\n            location: \"\",\n          } as UrlBox,\n        ],\n      } as DrefBox,\n    } as DinfBox;\n  }\n\n  private getStblBox(): StblBox {\n    const stco: StcoBox = {\n      type: \"stco\",\n      fullBoxHeader: {\n        version: 0,\n        flags: 0,\n      },\n      chunkOffsets: [this.mdat.dataStartOffset],\n    };\n\n    const stsc: StscBox = {\n      type: \"stsc\",\n      fullBoxHeader: {\n        version: 0,\n        flags: 0,\n      },\n      entries: [\n        {\n          firstChunk: 1,\n          samplesPerChunk: this.sampleCount,\n          sampleDescriptionIndex: 1,\n        },\n      ],\n    };\n\n    const stsd: StsdBox = {\n      type: \"stsd\",\n      fullBoxHeader: {\n        version: 0,\n        flags: 0,\n      },\n      entries: [\n        {\n          type: \"avc1\",\n          dataReferenceIndex: 1,\n          width: this.displaySize!.width, // TODO: Get from worker.\n          height: this.displaySize!.height,\n          horizontalResolution: 0x00480000,\n          verticalResolution: 0x00480000,\n          frameCount: 1,\n          compressorName: \"mp4.ts\",\n          depth: 24,\n          avcC: this.avcC!,\n        } as Avc1Box,\n      ],\n    };\n\n    const stss: StssBox = {\n      type: \"stss\",\n      fullBoxHeader: {\n        version: 0,\n        flags: 0,\n      },\n      sampleNumbers: this.syncSamples,\n    };\n\n    const stsz: StszBox = {\n      type: \"stsz\",\n      fullBoxHeader: {\n        version: 0,\n        flags: 0,\n      },\n      sampleCount: this.sampleCount,\n      sampleSizes: this.sampleSizes,\n    };\n\n    const stts: SttsBox = {\n      type: \"stts\",\n      fullBoxHeader: {\n        version: 0,\n        flags: 0,\n      },\n      entries: [\n        {\n          sampleCount: this.sampleCount,\n          sampleDelta: 1, // TODO: What if it ain't though?\n        },\n      ],\n    };\n\n    const stbl: StblBox = {\n      type: \"stbl\",\n      stco,\n      stsc,\n      stsd,\n      stss,\n      stsz,\n      stts,\n    };\n\n    return stbl;\n  }\n}\n","\nimport { StreamDataView } from \"stream-data-view\";\n\nimport VideoWorkerShared from \"./shared\";\nimport { MP4Parser, MP4Writer } from \"./mp4\";\nimport { Avc1Box, AvcCBox } from \"./mp4/types\";\n\nconst MAX_QUEUE_SIZE = 60;\nconst KEYFRAME_INTERVAL = 15;\nconst TINY_FRAME_SIZE = 100;\n\nfunction avcCBoxToDescription(avcCBox: AvcCBox): ArrayBuffer {\n  const stream = new StreamDataView(undefined, true);\n\n  stream.setNextUint8(avcCBox.configurationVersion);\n  stream.setNextUint8(avcCBox.profileIndication);\n  stream.setNextUint8(avcCBox.profileCompatibility);\n  stream.setNextUint8(avcCBox.levelIndication);\n  stream.setNextUint8(avcCBox.lengthSizeMinusOne + (63 << 2));\n\n  stream.setNextUint8(avcCBox.sequenceParameterSets.length + (7 << 5));\n  for (let i = 0; i < avcCBox.sequenceParameterSets.length; i++) {\n    stream.setNextUint16(avcCBox.sequenceParameterSets[i].length);\n    for (let j = 0; j < avcCBox.sequenceParameterSets[i].length; j++) {\n      stream.setNextUint8(avcCBox.sequenceParameterSets[i][j]);\n    }\n  }\n\n  stream.setNextUint8(avcCBox.pictureParameterSets.length);\n  for (let i = 0; i < avcCBox.pictureParameterSets.length; i++) {\n    stream.setNextUint16(avcCBox.pictureParameterSets[i].length);\n    for (let j = 0; j < avcCBox.pictureParameterSets[i].length; j++) {\n      stream.setNextUint8(avcCBox.pictureParameterSets[i][j]);\n    }\n  }\n\n  return stream.getBuffer();\n}\n\ntype ModifyFrameCallback = (frame: VideoFrame, index: number) => VideoFrame;\ntype ProgressInitCallback = (total: number) => void;\ntype ProgressCallback = (processed?: number, preview?: ImageBitmap) => void;\n\nexport interface ProcessorOptions {\n  modifyFrame: ModifyFrameCallback;\n  progressInit: ProgressInitCallback;\n  progressUpdate: ProgressCallback;\n}\n\nexport class Processor {\n  decoder?: VideoDecoder;\n  encoder?: VideoEncoder;\n\n  inMp4?: MP4Parser;\n  outMp4?: MP4Writer;\n\n  expectedFrames: number = 0;\n  framesDecoded: number = 0;\n  framesEncoded: number = 0;\n  queuedForDecode: number = 0;\n  queuedForEncode: number = 0;\n\n  modifyFrame: ModifyFrameCallback;\n  progressInit: ProgressInitCallback;\n  progressUpdate: ProgressCallback;\n\n  samplePromise = Promise.resolve();\n  decoderPromise = Promise.resolve();\n  encoderPromise = Promise.resolve();\n\n  processResolve?: () => void;\n  processReject?: (reason?: any) => void;\n\n  constructor(options: ProcessorOptions) {\n    this.modifyFrame = options.modifyFrame;\n    this.progressInit = options.progressInit;\n    this.progressUpdate = options.progressUpdate;\n  }\n\n  async open(file: File, outHandle: FileSystemFileHandle) {\n    this.reset();\n\n    this.inMp4 = new MP4Parser(file);\n    await this.inMp4.parse();\n\n    for (const [\n      index,\n      size,\n    ] of this.inMp4.moov!.trak[0].mdia.minf.stbl.stsz.sampleSizes.entries()) {\n      if (size <= TINY_FRAME_SIZE) {\n        console.warn(`Frame ${index} is too small (${size} bytes)!`);\n      }\n    }\n\n    this.outMp4 = new MP4Writer(outHandle);\n    await this.outMp4.open();\n\n    return {\n      width: this.inMp4.moov!.trak[0].tkhd.width,\n      height: this.inMp4.moov!.trak[0].tkhd.height,\n    };\n  }\n\n  process(options: { width: number; height: number }): Promise<void> {\n    return new Promise((resolve, reject) => {\n      this.processResolve = resolve;\n      this.processReject = reject;\n\n      try {\n        const avc1box = this.inMp4!.moov!.trak[0].mdia.minf.stbl.stsd\n          .entries[0] as Avc1Box;\n        const codec =\n          \"avc1.\" +\n          avc1box.avcC.profileIndication.toString(16).padStart(2, \"0\") +\n          avc1box.avcC.profileCompatibility.toString(16).padStart(2, \"0\") +\n          avc1box.avcC.levelIndication.toString(16).padStart(2, \"0\");\n\n        this.decoder!.configure({\n          codec: codec,\n          codedWidth: this.inMp4!.moov!.trak[0].tkhd.width,\n          codedHeight: this.inMp4!.moov!.trak[0].tkhd.height,\n          description: avcCBoxToDescription(\n            (this.inMp4!.moov!.trak[0].mdia.minf.stbl.stsd.entries[0] as Avc1Box)\n              .avcC\n          ),\n        });\n      } catch (e: any) {\n        throw new VideoWorkerShared.DecoderConfigureError(e);\n      }\n\n      try {\n        let bitrate =\n          (this.inMp4!.mdat!.header!.size * 8 * this.inMp4!.moov!.mvhd.timescale) /\n          this.inMp4!.moov!.mvhd.duration;\n        bitrate = Math.ceil(bitrate / 5_000_000) * 5_000_000;\n\n        this.encoder!.configure({\n          codec: \"avc1.42003d\",\n          width: options.width,\n          height: options.height,\n          bitrate: bitrate,\n          framerate: 60,\n          latencyMode: \"quality\",\n        });\n      } catch (e: any) {\n        throw new VideoWorkerShared.EncoderConfigureError(e);\n      }\n\n      this.outMp4?.setDisplaySize({\n        width: options.width,\n        height: options.height,\n      });\n\n      this.expectedFrames = this.inMp4!.moov!.trak[0].mdia.mdhd.duration;\n      this.progressInit(this.expectedFrames);\n\n      this.decodeNextSamples();\n    });\n  }\n\n  private reset() {\n    if (this.encoder) {\n      this.encoder.close();\n    }\n\n    this.encoder = new VideoEncoder({\n      output: this.handleEncodedFrame.bind(this),\n      error: this.handleEncoderError.bind(this),\n    });\n\n    if (this.decoder) {\n      this.decoder.close();\n    }\n\n    this.decoder = new VideoDecoder({\n      output: this.handleDecodedFrame.bind(this),\n      error: this.handleDecoderError.bind(this),\n    });\n\n    this.framesDecoded = 0;\n    this.framesEncoded = 0;\n    this.queuedForDecode = 0;\n    this.queuedForEncode = 0;\n    this.expectedFrames = 0;\n\n    this.samplePromise = Promise.resolve();\n    this.decoderPromise = Promise.resolve();\n    this.encoderPromise = Promise.resolve();\n\n    this.processResolve = undefined;\n    this.processReject = undefined;\n  }\n\n  private decodeNextSamples() {\n    this.samplePromise = this.samplePromise.then(async () => {\n      let remainingSamples = this.expectedFrames - this.queuedForDecode;\n      if (remainingSamples <= 0) {\n        // console.debug(\"No more samples to decode\");\n        return;\n      } else {\n        // console.debug(`Remaining samples: ${remainingSamples}`);\n      }\n\n      // console.debug(\n      //   `Dec queue: ${this.decoder!.decodeQueueSize}, Enc queue: ${\n      //     this.encoder!.encodeQueueSize\n      //   }`\n      // );\n      if (\n        (this.decoder!.decodeQueueSize > MAX_QUEUE_SIZE ||\n          this.encoder!.encodeQueueSize > MAX_QUEUE_SIZE) &&\n        remainingSamples > MAX_QUEUE_SIZE\n      ) {\n        // console.debug(\"Queues too full, not adding more samples\");\n        return;\n      }\n\n      const sample = await this.inMp4!.getSample(this.queuedForDecode);\n      if (sample.data.byteLength <= TINY_FRAME_SIZE) {\n        // TODO: I think this needs handled in order.\n        console.warn(`Skipping tiny frame ${this.queuedForDecode}`);\n        this.queuedForDecode++;\n        this.framesDecoded++;\n        this.queuedForEncode++;\n        this.framesEncoded++;\n        this.decodeNextSamples();\n        return;\n      }\n\n      const chunk = new EncodedVideoChunk({\n        type: sample.sync ? \"key\" : \"delta\",\n        timestamp: 0,\n        duration: 60,\n        data: sample.data.buffer,\n      });\n\n      this.decoder!.decode(chunk);\n      this.queuedForDecode++;\n      remainingSamples--;\n\n      if (this.inMp4?.isSampleSync(this.queuedForDecode)) {\n        // Next frame is a keyframe, so flush.\n        this.decoder!.flush();\n      }\n\n      this.decodeNextSamples();\n    });\n  }\n\n  private handleDecodedFrame(frame: VideoFrame) {\n    this.decoderPromise = this.decoderPromise.then(async () => {\n      if (this.framesDecoded % KEYFRAME_INTERVAL === 0) {\n        // console.debug(\n        //   `Flushing encoder at decoded frame ${this.framesDecoded}, keyframe incoming.`\n        // );\n        this.encoder!.flush();\n      }\n\n      const modifiedFrame = this.modifyFrame!(frame, this.framesDecoded);\n      frame.close();\n\n      this.encoder!.encode(modifiedFrame, {\n        keyFrame: this.framesDecoded % KEYFRAME_INTERVAL === 0,\n      });\n\n      this.queuedForEncode++;\n\n      if (this.framesDecoded % KEYFRAME_INTERVAL === 0) {\n        createImageBitmap(modifiedFrame).then((previewBitmap) => {\n          this.progressUpdate(undefined, previewBitmap);\n        });\n      }\n      modifiedFrame.close();\n\n      this.framesDecoded++;\n      if (this.framesDecoded === this.expectedFrames - 1) {\n        // console.debug(\n        //   `Flushing encoder at decoded frame ${this.framesDecoded}, last frame.`\n        // );\n        this.encoder!.flush();\n      }\n    });\n  }\n\n  private handleEncodedFrame(\n    chunk: EncodedVideoChunk,\n    metadata: EncodedVideoChunkMetadata\n  ) {\n    this.encoderPromise = this.encoderPromise.then(async () => {\n      if (this.framesEncoded === 0) {\n        this.outMp4!.setAvcC(metadata.decoderConfig?.description!);\n      }\n      this.framesEncoded++;\n\n      // console.debug(`Encoded frame ${this.framesEncoded}`);\n      const buffer = new ArrayBuffer(chunk.byteLength);\n      chunk.copyTo(buffer);\n\n      await this.outMp4!.writeSample(buffer, chunk.type === \"key\");\n      this.progressUpdate(this.framesEncoded);\n\n      if (this.framesEncoded === this.expectedFrames) {\n        await this.outMp4?.close();\n        this.processResolve!();\n      } else {\n        this.decodeNextSamples();\n      }\n    });\n  }\n\n  private handleDecoderError(e: Error) {\n    this.processReject!(new VideoWorkerShared.DecoderError(e.message));\n    throw e;\n  }\n\n  private handleEncoderError(e: Error) {\n    this.processReject!(new VideoWorkerShared.EncoderError(e.message));\n    throw e;\n  }\n}\n","export const SD_TILE_WIDTH = 12 * 3;\nexport const SD_TILE_HEIGHT = 18 * 3;\n\nexport const HD_TILE_WIDTH = 12 * 2;\nexport const HD_TILE_HEIGHT = 18 * 2;\n\nexport const TILES_PER_PAGE = 256;\n\nexport interface FontPack {\n  sd1: Font;\n  sd2: Font;\n  hd1: Font;\n  hd2: Font;\n}\n\nexport interface FontPackFiles {\n  sd1: File;\n  sd2: File;\n  hd1: File;\n  hd2: File;\n}\n\nexport class Font {\n  readonly name: string;\n  readonly tiles: ImageBitmap[];\n\n  constructor(name: string, tiles: ImageBitmap[]) {\n    this.name = name;\n    this.tiles = tiles;\n  }\n\n  getTile(index: number): ImageBitmap {\n    return this.tiles[index];\n  }\n\n  static async fromFile(file: File): Promise<Font> {\n    const data = await file.arrayBuffer();\n    const isHd = file.name.includes(\"hd\");\n\n    const tileWidth = isHd ? HD_TILE_WIDTH : SD_TILE_WIDTH;\n    const tileHeight = isHd ? HD_TILE_HEIGHT : SD_TILE_HEIGHT;\n\n    const tiles: ImageBitmap[] = [];\n    for (let tileIndex = 0; tileIndex < TILES_PER_PAGE; tileIndex++) {\n      const pixData = new Uint8ClampedArray(\n        data,\n        tileIndex * tileWidth * tileHeight * 4,\n        tileWidth * tileHeight * 4\n      );\n\n      const imageData = new ImageData(pixData, tileWidth, tileHeight);\n      const imageBitmap = await createImageBitmap(imageData);\n      tiles.push(imageBitmap);\n    }\n\n    return new Font(file.name, tiles);\n  }\n\n  static async fromFiles(files: FontPackFiles): Promise<FontPack> {\n    return {\n      sd1: await Font.fromFile(files.sd1),\n      sd2: await Font.fromFile(files.sd2),\n      hd1: await Font.fromFile(files.hd1),\n      hd2: await Font.fromFile(files.hd2),\n    };\n  }\n}\n","import { StreamDataView } from \"stream-data-view\";\n\ninterface OsdHeader {\n  magic: string;\n  version: number;\n  config: OsdConfig;\n}\n\ninterface OsdConfig {\n  charWidth: number;\n  charHeight: number;\n  fontWidth: number;\n  fontHeight: number;\n  xOffset: number;\n  yOffset: number;\n  fontVariant: number;\n}\n\ninterface OsdFrame {\n  frameNumber: number;\n  frameSize: number;\n  frameData: Uint16Array;\n}\n\nexport class OsdReader {\n  readonly header: OsdHeader;\n  readonly frames: OsdFrame[] = [];\n\n  constructor(data: ArrayBuffer) {\n    const stream = new StreamDataView(data);\n    this.header = {\n      magic: stream.getNextString(7),\n      version: stream.getNextUint16(),\n      config: {\n        charWidth: stream.getNextUint8(),\n        charHeight: stream.getNextUint8(),\n        fontWidth: stream.getNextUint8(),\n        fontHeight: stream.getNextUint8(),\n        xOffset: stream.getNextUint16(),\n        yOffset: stream.getNextUint16(),\n        fontVariant: stream.getNextUint8(),\n      },\n    };\n\n    if (this.header.config.charWidth === 31) {\n      this.header.config.charWidth = 30;\n    }\n\n    while (stream.getOffset() < data.byteLength) {\n      try {\n        const frameNumber = stream.getNextUint32();\n        const frameSize = stream.getNextUint32();\n        const frameData = new Uint16Array(data, stream.getOffset(), frameSize);\n        stream.setOffset(stream.getOffset() + frameSize * 2);\n\n        this.frames.push({\n          frameNumber,\n          frameSize,\n          frameData,\n        });\n      } catch (e) {\n        if (e instanceof RangeError) {\n          console.warn(\"No more data in OSD file, probably truncated due to power loss\");\n          break;\n        }\n      }\n    }\n  }\n\n  static async fromFile(file: File): Promise<OsdReader> {\n    const data = await file.arrayBuffer();\n    return new OsdReader(data);\n  }\n}\n","/// <reference lib=\"webworker\" />\n\nimport VideoWorkerShared from \"./shared\";\nimport { Processor } from \"./processor\";\nimport {\n  Font,\n  FontPack,\n  FontPackFiles,\n  TILES_PER_PAGE,\n} from \"./fonts\";\nimport { OsdReader } from \"./osd\";\n\nconst MAX_DISPLAY_X = 60;\nconst MAX_DISPLAY_Y = 22;\n\nexport class VideoWorker {\n  readonly processor: Processor;\n  fontPack?: FontPack;\n  osdReader?: OsdReader;\n\n  lastOsdIndex: number = 0;\n\n  wide: boolean = false;\n  hd: boolean = false;\n  outWidth?: number;\n  outHeight?: number;\n\n  osdCanvas?: OffscreenCanvas;\n  osdCtx?: OffscreenCanvasRenderingContext2D;\n  frameCanvas?: OffscreenCanvas;\n  frameCtx?: OffscreenCanvasRenderingContext2D;\n\n  constructor() {\n    this.processor = new Processor({\n      modifyFrame: this.modifyFrame.bind(this),\n      progressInit: this.progressInit.bind(this),\n      progressUpdate: this.progressUpdate.bind(this),\n    });\n\n    addEventListener(\"message\", this.onMessage.bind(this)); // eslint-disable-line no-restricted-globals\n  }\n\n  async start(options: {\n    fontFiles: FontPackFiles,\n    osdFile: File,\n    videoFile: File,\n    outHandle: FileSystemFileHandle,\n  }) {\n    this.osdReader = await OsdReader.fromFile(options.osdFile);\n    this.fontPack = await Font.fromFiles(options.fontFiles);\n\n    const { width, height } = await this.processor.open(options.videoFile, options.outHandle);\n\n    if (width === 1280 && height === 720) {\n      this.wide = true;\n    }\n\n    if (this.osdReader!.header.config.fontWidth === 24) {\n      this.hd = true;\n    }\n\n    let outWidth: number;\n    let outHeight: number;\n    if (this.wide || this.hd) {\n      outWidth = 1280;\n      outHeight = 720;\n    } else {\n      outWidth = width;\n      outHeight = height;\n    }\n\n    this.outWidth = outWidth;\n    this.outHeight = outHeight;\n\n    this.osdCanvas = new OffscreenCanvas(\n      this.osdReader!.header.config.fontWidth *\n        this.osdReader!.header.config.charWidth,\n      this.osdReader!.header.config.fontHeight *\n        this.osdReader!.header.config.charHeight\n    );\n    this.osdCtx = this.osdCanvas.getContext(\"2d\")!;\n\n    this.frameCanvas = new OffscreenCanvas(this.outWidth!, this.outHeight!);\n    this.frameCtx = this.frameCanvas.getContext(\"2d\")!;\n\n    try {\n      await this.processor.process({\n        width: outWidth,\n        height: outHeight,\n      });\n\n      this.postMessage({\n        type: VideoWorkerShared.MessageType.COMPLETE,\n      });\n    } catch (e: any) {\n      this.postMessage({\n        type: VideoWorkerShared.MessageType.ERROR,\n        error: e,\n      });\n      throw e;\n    }\n  }\n\n  modifyFrame(frame: VideoFrame, frameIndex: number): VideoFrame {\n    const osdCanvas = this.osdCanvas!;\n    const osdCtx = this.osdCtx!;\n    const frameCanvas = this.frameCanvas!;\n    const frameCtx = this.frameCtx!;\n\n    frameCtx.fillStyle = \"black\";\n    frameCtx.fillRect(0, 0, frameCanvas.width, frameCanvas.height);\n    osdCtx.clearRect(0, 0, osdCanvas.width, osdCanvas.height);\n\n    let frameXOffset: number;\n    if (this.hd || this.wide) {\n      frameXOffset = (this.outWidth! - frame.displayWidth) / 2;\n    } else {\n      frameXOffset = 0;\n    }\n    frameCtx.drawImage(frame, frameXOffset, 0);\n\n    if (this.lastOsdIndex < this.osdReader!.frames.length - 1) {\n      const nextOsdIndex = this.lastOsdIndex + 1;\n      const nextOsdFrame = this.osdReader!.frames[nextOsdIndex];\n\n      if (frameIndex >= nextOsdFrame.frameNumber) {\n        this.lastOsdIndex = nextOsdIndex;\n      }\n    }\n\n    const osdFrame = this.osdReader!.frames[this.lastOsdIndex];\n    for (let y = 0; y < MAX_DISPLAY_Y; y++) {\n      for (let x = 0; x < MAX_DISPLAY_X; x++) {\n        const osdFrameIndex = y + MAX_DISPLAY_Y * x;\n        const osdFrameChar = osdFrame.frameData[osdFrameIndex];\n\n        let font: Font;\n        if (this.hd) {\n          font =\n            osdFrameChar < TILES_PER_PAGE\n              ? this.fontPack!.hd1\n              : this.fontPack!.hd2;\n        } else {\n          font =\n            osdFrameChar < TILES_PER_PAGE\n              ? this.fontPack!.sd1\n              : this.fontPack!.sd2;\n        }\n\n        osdCtx.drawImage(\n          font.getTile(osdFrameChar % TILES_PER_PAGE),\n          x * this.osdReader!.header.config.fontWidth,\n          y * this.osdReader!.header.config.fontHeight\n        );\n      }\n    }\n\n    // Try fit vertically, then try horizontally.\n    let osdScale: number;\n    if (\n      frameCanvas.height / osdCanvas.height <\n      frameCanvas.width / osdCanvas.width\n    ) {\n      osdScale = frameCanvas.height / osdCanvas.height;\n    } else {\n      osdScale = frameCanvas.width / osdCanvas.width;\n    }\n\n    const osdWidth = osdCanvas.width * osdScale;\n    const osdHeight = osdCanvas.height * osdScale;\n\n    const osdXOffset = (frameCanvas.width - osdWidth) / 2;\n    const osdYOffset = (frameCanvas.height - osdHeight) / 2;\n\n    frameCtx.drawImage(osdCanvas, osdXOffset, osdYOffset, osdWidth, osdHeight);\n\n    return new VideoFrame(frameCanvas as any, { timestamp: frame.timestamp! });\n  }\n\n  progressInit(expectedFrames: number) {\n    this.postMessage({\n      type: VideoWorkerShared.MessageType.PROGRESS_INIT,\n      expectedFrames,\n    });\n  }\n\n  progressUpdate(currentFrame?: number, preview?: ImageBitmap) {\n    this.postMessage(\n      {\n        type: VideoWorkerShared.MessageType.PROGRESS_UPDATE,\n        currentFrame,\n        preview,\n      },\n      [...(preview ? [preview] : [])]\n    );\n  }\n\n  onMessage(event: MessageEvent<VideoWorkerShared.Message>) {\n    const message = event.data;\n    switch (message.type) {\n      case VideoWorkerShared.MessageType.START: {\n        this.start({\n          fontFiles: message.fontFiles,\n          osdFile: message.osdFile,\n          videoFile: message.videoFile,\n          outHandle: message.outHandle,\n        });\n        break;\n      }\n\n      default: {\n        throw new Error(\"Unknown message type received\");\n      }\n    }\n  }\n\n  private postMessage(message: VideoWorkerShared.Message, transfer?: Transferable[]) {\n    if (transfer) {\n      postMessage(message, transfer);\n    } else {\n      postMessage(message);\n    }\n  }\n}\n\nnew VideoWorker();\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [467], function() { return __webpack_require__(46646); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n\tvar getter = module && module.__esModule ?\n\t\tfunction() { return module['default']; } :\n\t\tfunction() { return module; };\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"fc4cc16e\" + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","__webpack_require__.p = \"/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t646: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkwtfos_configurator\"] = self[\"webpackChunkwtfos_configurator\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn __webpack_require__.e(467).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["MessageType","DecoderError","message","name","Error","DecoderConfigureError","EncoderError","EncoderConfigureError","VideoWorkerShared","FileStreamReader","file","buffer","ArrayBuffer","bufferOffset","_offset","this","length","getNextBytes","bytes","byteBuffer","getNextUint8","byte","push","Uint8Array","decoder","TextDecoder","string","decode","getDataView","view","getUint8","getUint16","getUint32","getBigUint64","result","i","offset","bufferEndOffset","size","fillEndOffset","newBufferOffset","Math","floor","BUFFER_SIZE","newBufferEndOffset","ceil","slice","arrayBuffer","fillBuffer","DataView","byteLength","FileStreamWriter","stream","_size","value","array","writeNextBytes","setUint16","setUint32","BigInt","setBigUint64","undefined","TextEncoder","encodeInto","getStream","write","Blob","seek","close","createWritable","truncate","parseBox","startOffset","getNextUint32","getNextString","type","console","debug","Number","getNextUint64","boxParsers","UrlBoxParser","UrnBoxParser","avc1","Avc1BoxParser","avcC","AvcCBoxParser","co64","Co64BoxParser","dinf","DinfBoxParser","dref","DrefBoxParser","ftyp","FtypBoxParser","hdlr","HdrlBoxParser","mdat","MdatBoxParser","mdhd","MdhdBoxParser","mdia","MdiaBoxParser","minf","MinfBoxParser","moov","MoovBoxParser","mvhd","MvhdBoxParser","stbl","StblBoxParser","stco","StcoBoxParser","stsc","StscBoxParser","stsd","StsdBoxParser","stss","StssBoxParser","stsz","StszBoxParser","stts","SttsBoxParser","tkhd","TkhdBoxParser","trak","TrakBoxParser","udta","UdtaBoxParser","vmhd","VmhdBoxParser","parser","warn","UnknownBoxParser","parse","BoxParser","header","getHeader","endOffset","boxes","getNextChildBox","box","diff","SimpleBoxParser","seekToEnd","FullBoxParser","version","flags","getFullBoxHeader","fullBoxHeader","majorBrand","minorVersion","compatibleBrands","getChildBoxes","childBoxes","creationTime","modificationTime","timescale","duration","rate","getNextUint16","volume","matrix","nextTrackId","trackId","layer","alternateGroup","width","height","language","entryCount","entries","nextChild","dataReferenceIndex","horizontalResolution","verticalResolution","frameCount","compressorName","depth","configurationVersion","profileIndication","profileCompatibility","levelIndication","lengthSizeMinusOne","spsCount","sps","spsLength","spsData","ppsCount","pps","ppsLength","ppsData","sequenceParameterSets","pictureParameterSets","sampleNumbers","chunkOffsets","firstChunk","samplesPerChunk","sampleDescriptionIndex","sampleSizes","sampleCount","sampleDelta","handlerType","graphicsMode","opColor","location","writeBox","writer","UrlBoxWriter","UrnBoxWriter","Avc1BoxWriter","AvcCBoxWriter","DinfBoxWriter","DrefBoxWriter","FtypBoxWriter","HdlrBoxWriter","MdhdBoxWriter","MdiaBoxWriter","MinfBoxWriter","MoovBoxWriter","MvhdBoxWriter","StblBoxWriter","StcoBoxWriter","StscBoxWriter","StsdBoxWriter","StssBoxWriter","StszBoxWriter","SttsBoxWriter","TkhdBoxWriter","TrakBoxWriter","VmhdBoxWriter","BoxWriter","writeNextUint32","writeNextString","writeContents","FullBoxWriter","writeNextUint8","compatibleBrand","sequenceParameterSet","writeNextUint16","skip","entry","color","chunkOffset","sampleSize","sampleNumber","MdatBoxStreamWriter","sizeOffset","opened","closed","writeNextUint64","MP4Parser","eof","sampleOffset","isSampleSync","data","sync","includes","MP4Writer","syncSamples","displaySize","open","avcCStruct","byteOffset","options","getMvhdBox","getTrakBox","getTkhdBox","getMdiaBox","startDate","Date","nowDate","diffSeconds","getTime","getMinfBox","getMdhdBox","getStblBox","getDinfBox","dataStartOffset","avcCBoxToDescription","avcCBox","StreamDataView","setNextUint8","setNextUint16","j","getBuffer","Processor","encoder","inMp4","outMp4","expectedFrames","framesDecoded","framesEncoded","queuedForDecode","queuedForEncode","modifyFrame","progressInit","progressUpdate","samplePromise","Promise","resolve","decoderPromise","encoderPromise","processResolve","processReject","outHandle","reset","index","reject","avc1box","codec","toString","padStart","configure","codedWidth","codedHeight","description","e","bitrate","framerate","latencyMode","setDisplaySize","decodeNextSamples","VideoEncoder","output","handleEncodedFrame","bind","error","handleEncoderError","VideoDecoder","handleDecodedFrame","handleDecoderError","then","remainingSamples","decodeQueueSize","encodeQueueSize","getSample","sample","chunk","EncodedVideoChunk","timestamp","flush","frame","modifiedFrame","encode","keyFrame","createImageBitmap","previewBitmap","metadata","setAvcC","decoderConfig","copyTo","writeSample","TILES_PER_PAGE","Font","tiles","isHd","tileWidth","tileHeight","tileIndex","pixData","Uint8ClampedArray","imageData","ImageData","imageBitmap","files","fromFile","sd1","sd2","hd1","hd2","OsdReader","frames","magic","config","charWidth","charHeight","fontWidth","fontHeight","xOffset","yOffset","fontVariant","getOffset","frameNumber","frameSize","frameData","Uint16Array","setOffset","RangeError","VideoWorker","processor","fontPack","osdReader","lastOsdIndex","wide","hd","outWidth","outHeight","osdCanvas","osdCtx","frameCanvas","frameCtx","addEventListener","onMessage","osdFile","fromFiles","fontFiles","videoFile","OffscreenCanvas","getContext","process","postMessage","frameIndex","frameXOffset","fillStyle","fillRect","clearRect","displayWidth","drawImage","nextOsdIndex","osdScale","osdFrame","y","x","osdFrameIndex","osdFrameChar","font","getTile","osdWidth","osdHeight","osdXOffset","osdYOffset","VideoFrame","currentFrame","preview","event","start","transfer","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","call","m","__webpack_exports__","O","deferred","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","Object","keys","every","key","splice","r","n","getter","__esModule","d","a","definition","o","defineProperty","enumerable","get","f","chunkId","all","reduce","promises","u","miniCssF","obj","prop","prototype","hasOwnProperty","p","installedChunks","importScripts","chunkLoadingGlobal","self","parentChunkLoadingFunction","moreModules","runtime","pop","next"],"sourceRoot":""}